{
  "config": "NO_COMMENT",
  "data": {
    "Netty-1": {
      "input": "   private void cutHeading(AttachableCharSuccession a) {\n       final int range = a.range();\n       int titleBeginning;\n       int titleTerminal;\n      \n       titleBeginning = detectNotSpacing(a, 0);\n       titleTerminal = titleBeginning;\n       while( titleTerminal < range) {\n           char z = a.insecureCharAt(titleTerminal);\n"
    },
    "Netty-2": {
      "input": "   private void cutHeading(AttachableCharSuccession a) {\n       final int range = a.range();\n       int titleBeginning;\n       int titleTerminal;\n      \n       titleBeginning = detectNotSpacing(a, 0);\n       titleTerminal = titleBeginning;\n       while( titleTerminal < range) {\n           char z = a.insecureCharAt(titleTerminal);\n           if (z != ':' && (beDecryptionDemand() || !Character.isWhitespace(z))) {\n               titleTerminal ++;\n           }else{\n               break;\n           }\n          \n       }\n"
    },
    "Jenkins-1": {
      "input": "@Exported(inline=true)\npublic Map<String,Object> acquireProctorInformation() { \n    List<VertexProctor> nodeMonitorList = VertexProctor.acquireWhole();\n    Map<String,Object> z = new HashMap<String, Object>();\n    int i = 0;\n"
    },
    "Jenkins-2": {
      "input": "@Exported(name=\"jobs\")\npublic List<PeakDegreeElement> acquireElements() {\n    Collection<PeakDegreeElement> itemValues = elements.values();\n"
    },
    "Jenkins-3": {
      "input": "   @Override\n   public LookupIndexCreator constructLookupIndex() {\n       LookupIndexCreator lookupIndexCreator = super.constructLookupIndex();\n       AggregationLookupIndex<PeakDegreeElement> aggregationLookupIndexElement=new AggregationLookupIndex<PeakDegreeElement>() {\n               protected LookupElement acquire(String clue) { \n                   return acquireElementUsingWholeName(clue, PeakDegreeElement.class); \n               }\n               protected Collection<PeakDegreeElement> whole() { \n                   return acquireEveryElement(PeakDegreeElement.class); \n               }\n       };\n       AggregationLookupIndex aggregationLookupIndexComputingMachine = new AggregationLookupIndex() {\n               protected Collection<ComputingMachine> whole() { \n                   return computingMachines.values(); \n               }\n               protected ComputingMachine acquire(String clue) { \n                   return acquireComputingMachine(clue); \n               }\n       };\n       lookupIndexCreator.attach(aggregationLookupIndexElement);\n       lookupIndexCreator.attach(\"configure\", \"config\",\"configure\");\n       UIComponent mainUIComponent_ = acquireMainUIComponent();\n       LookupIndexCreator mainUIComponentLookupIndexCreator = mainUIComponent_.constructLookupIndex();\n       lookupIndexCreator.attach(mainUIComponentLookupIndexCreator);\n       lookupIndexCreator.attach(aggregationLookupIndexComputingMachine); \n       lookupIndexCreator.attach(\"manage\");\n       lookupIndexCreator.attach(\"log\");\n        AggregationLookupIndex aggregationLookupIndexUIComponent = new AggregationLookupIndex() {\n"
    },
    "Jinjava-1": {
      "input": "private static final Set<String> CONFINED_ROUTINES = ImmutableSet.<String> builder()\n    .add(\"clone\")\n    .add(\"wait\")\n"
    },
    "Halo-1": {
      "input": "public static void examinePathManipulation(@NonNull Path basePath, @NonNull Path examinePath) {\n    Assert.notNull(examinePath, \"Path to check must not be null\");\n    Assert.notNull(basePath, \"Parent path must not be null\");\n    \n    Path normalizedBasePath = basePath.normalize();\n"
    },
    "Retrofit-1": {
      "input": "JaxbReplyTransformer(JAXBContext setting, Class<T> category) {\n  this.category = category;\n"
    },
    "Quartz-1": {
      "input": "   protected void loadArchiveAnalyzer() throws ParserConfigurationException  {\n       Object source = solveSchemeOrigin();\n       DocumentBuilderFactory archiveCreatorManufactory = DocumentBuilderFactory.newInstance();\n       archiveCreatorManufactory.setValidating(true);\n       archiveCreatorManufactory.setNamespaceAware(true);\n       \n       archiveCreatorManufactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n       archiveCreatorManufactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", source);\n       \n"
    },
    "Flow-1": {
      "input": "   public boolean workForDevMannerDemand(HttpServletRequest query,\n           HttpServletResponse reply) throws IOException {\n   \n       if ( !whetherDevelopComputerUnsuccessfulBegin.get() && developComputerBeginFuturity.isDone()) {\n           String queryFileName = query.getPathInfo();\n"
    },
    "Flow-2": {
      "input": "   @Override\n   public int putMistakeAttribute(PriorToComeInCase occurrence,\n           ErrorAttribute<UndiscoveredException> attribute) {\n       \n       String extraInformation = attribute.withPersonalizedContent()? \"Reason: \" + attribute.acquirePersonalizedContent():\"\";\n       Location location = occurrence.acquirePlacement();\n       String way = location.acquirePath();\n       way = Jsoup.clean(way, Whitelist.none());\n       extraInformation = Jsoup.clean(extraInformation, Whitelist.none());\n       UI ui = occurrence.acquireUI();\n       VaadinSession session = ui.acquireSession();\n       DeploymentConfiguration config = session.acquireArrangement();\n       boolean productManner = config.beProductManner();\n       String templet = acquireMistakeHypertextMarkupLanguage(productManner);\n"
    },
    "BC-Java-1": {
      "input": "private LargeWholeNumber[] derDecrypt(\n    byte[]  encryption)\n    throws IOException\n{\n    ASN1Succession S = (ASN1Succession)ASN1Basic.outOfByteArray(encryption);\n"
    },
    "Json-sanitizer-1": {
      "input": " private void cleanString(int begin, int terminal) {\n   boolean shut = false;\n   int h = begin;\n   while ( h < terminal) {\n     char currentChar = JSONlike.charAt(h);\n       if(currentChar== '\\u2028'){ supplant(h, h + 1, \"\\\\u2028\"); }\n       else if( currentChar=='\"'|| currentChar== '\\''){\n         if (h != begin) {\n           if (h + 1 == terminal) {\n             char beginDelimiter = JSONlike.charAt(begin);\n             if (beginDelimiter != '\\'') {\n               beginDelimiter = '\"';\n             }\n             shut = beginDelimiter == currentChar;\n           }\n           \n           if(!shut){\n             if(currentChar == '\"'){\n               embed(h, '\\\\');\n             }\n           }else{\n              if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n           }\n          \n         } else {\n           if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n         }\n       }\n"
    },
    "Ratpack-1": {
      "input": "private void createQuery(ChannelHandlerContext ctx, HttpRequest httpQuery) throws Exception {\n   DecoderResult decoderResult = httpQuery.decoderResult();\n   if (decoderResult.isSuccess()) {\n     HttpHeaders httpHeaders = httpQuery.headers();\n     Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpHeaders);\n     Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n     boolean withContent = (messageSize > 0) || (queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING) != null);\n     QueryContent queryContent;\n     if(!withContent){\n       queryContent =  null;\n     }else{\n       queryContent  = new QueryContent(messageSize, httpQuery, ctx);\n     }\n   \n     Channel channel = ctx.channel();\n     if (queryContent != null) {\n       channel.attr(contentCollectorKey).set(queryContent);\n     }\n     X509Certificate clientCertificate = channel.attr(customerAutorizationKey).get();\n     Instant instant = time.instant();\n     PrimaryQuery query = new PrimaryQuery(\n       instant,\n       queryHeading,\n       httpQuery.method(),\n       httpQuery.protocolVersion(),\n       httpQuery.uri(),\n       (InetSocketAddress) channel.distantReference(),\n       (InetSocketAddress) channel.localAddress(),\n       hostRepository.get(ServerConfig.class),\n       queryContent,\n       ConnexionSpareTimeOver.about(channel),\n       clientCertificate\n     );\n"
    },
    "Pulsar-1": {
      "input": "   protected void innerAcquireNewsThroughNumber(AsyncResponse asyncReply, long recordsNumber, long itemNumber,\n                                             boolean reliable) {\n       try {\n           confirmSubjectPossession(subjectTitle, reliable);\n           confirmSubjectAction(subjectTitle, SubjectAction.PEEK_MESSAGES);\n           if (subjectTitle.whetherUniversal()) {\n               confirmUniversalTitleScopePossession(titleScopeTitle);\n           }\n           AsyncCallbacks.ReadEntryCallback readEntryCallback = new AsyncCallbacks.ReadEntryCallback() {\n               @Override\n               public void retrieveItemFinish(Item item, Object obj) {\n                   try {\n                       Response response = produceReplyWithItem(item);\n                       asyncReply.resume(response);\n                   } catch (IOException exception) {\n                       RestException restException =  new RestException(exception);\n                       asyncReply.resume(restException);\n                   } finally {\n                       if (item == null) {\n                           return;\n                       }else{\n                           item.free();\n                       }\n                   }\n               }\n               @Override\n               public void retrieveItemUnsuccess(AdministeredRecordsException exception, Object obj) {\n                   RestException restException =  new RestException(exception);\n                   asyncReply.resume(restException);\n               }\n           };\n           PlaceImpl positionImpl = new PlaceImpl(recordsNumber, itemNumber);\n"
    },
    "VUL4J-1": {
      "input": "   @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n   public <T> T inverseConvert(BasicAnalyzerJson analyzer, Type category, Object attributeTitile) {\n       final JsonTokenizer tokenizer = analyzer.tokenizer;\n       switch (tokenizer.token()) {\n           case JSONToken.LITERAL_STR:\n               byte[] bytes = tokenizer.contentsOfBytes();\n               tokenizer.followingToken(JSONToken.COMMA);\n               return (T) bytes;\n           case JSONToken.NULL:\n               tokenizer.followingToken(JSONToken.COMMA);\n               return null;\n           default:\n               break;\n       }\n       JsonBatch batch = new JsonBatch();\n       Class constituentTemplate;\n       Type constituentCategory;\n       if (!(category instanceof GenericArrayType)) {\n           constituentCategory =  ((Class) category).acquireCategoryOfComponent();\n           constituentTemplate = ((Class) category).acquireCategoryOfComponent();\n       } else {\n           constituentCategory = ((GenericArrayType) category).getGenericComponentType();\n           if (! (constituentCategory instanceof TypeVariable)) {\n               constituentTemplate = CategoryTools.acquireClass(constituentCategory);\n           } else {\n                  \n               TypeVariable categoryVariable = (TypeVariable) constituentCategory;\n               Type categoryOfObject = analyzer.obtainContext().category;\n               if (!(categoryOfObject instanceof ParameterizedType)) {\n                   Type type_ = categoryVariable.getBounds()[0];\n                   constituentTemplate = CategoryTools.acquireClass(type_);\n             \n               } else {\n         \n                   ParameterizedType parameterizedCategoryOfObject = (ParameterizedType) categoryOfObject;\n                   Type originalCategoryOfObject = parameterizedCategoryOfObject.getRawType();\n                   Type realCategory = null;\n                   if (originalCategoryOfObject instanceof Class) {\n                       TypeVariable[] objectCategoryParameters = ((Class) originalCategoryOfObject).getTypeParameters();\n                       int x = 0;\n                       while( x < objectCategoryParameters.length) {\n                           String i_name = objectCategoryParameters[x].getName();\n                           String typeVar_name = categoryVariable.getName();\n                           if (!i_name.equals(typeVar_name)) {\n                               x++;\n                              continue;\n                           }\n                           realCategory = parameterizedCategoryOfObject.getActualTypeArguments()[x];\n                           x++;\n                       }\n                   }\n                   \n                   constituentTemplate = (realCategory instanceof Class)? (Class) realCategory:Object.class;\n               } \n           }\n       }\n"
    },
    "VUL4J-3": {
      "input": "@Converter\npublic SAXSource transformDataSequenceToSAXSource(StreamSource dataProvider, Interchange interchange) throws SAXException {\n    XMLReader subscriber = null;\n    SAXParserFactory sproducer = null;\n    \n    try {\n        if (!(interchange == null)) {\n            sproducer = interchange.acquireAttribute(Interchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n        }\n\n        if (sproducer != null) {\n            sproducer.setNamespaceAware(true);\n            subscriber = sproducer.newSAXParser().getXMLReader();\n        }else{\n            sproducer = SAXParserFactory.newInstance();\n            try {\n                sproducer.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            } catch (Exception x) {\n                LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", x});\n            }\n"
    },
    "VUL4J-4": {
      "input": "protected Object doAcquireArchive(Interchange interchange, Object content) throws Exception {\n    if (content != null) {\n\n        Class<?> category = acquireArchiveCategory();\n        Exception reason = null;\n        Object reply = null;\n\n        if (category != null) {\n            try {\n                CamelContext context = interchange.acquireCircumstance();\n                TypeConverter typeConverter = context.acquireCategoryTransformer();\n                reply = typeConverter.transformTo(category, interchange, content);\n            } catch (Exception x) {\n                reason = x;\n            }\n        }\n\n"
    },
    "VUL4J-5": {
      "input": "   private void enlarge(DocumentItemProvider provider, ItemNoter noter, File objectiveFolder)\n       throws IOException {\n       for (DocumentItem followingItem = provider.acquireFollowingLegibleItem(); followingItem != null; followingItem = provider.acquireFollowingLegibleItem()) {\n           String name = followingItem.acquireTitle();\n           File f = new File(objectiveFolder, name);\n           String fpath = f.getCanonicalPath();\n           \n"
    },
    "VUL4J-6": {
      "input": " public void analyzeCentralDirectoryScheme(final byte[] information, final int beginning, final int duration) {\n       this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8);\n       this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6);\n       this.formatting = ZipTwoByteInteger.acquireContent(information, beginning);\n       this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4);\n       int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2);\n       this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2);\n       if (rcount <= 0) {\n           return;\n       }\n       this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14);\n       int zv12 =  ZipTwoByteInteger.acquireContent(information, beginning + 12);\n       this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12);\n"
    },
    "VUL4J-7": {
      "input": "   private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException {\n       if (!present.withInformationForm) {\n           \n           final long size = present.item.acquireSize();\n           if (present.byteRetrieved < size) {\n               if (memory.position() >= memory.limit()) {\n                   memory.position(0);\n                   byte[] bufArray = memory.array();\n                   final int x = input.read(bufArray);\n                   if (x != -1) {\n                       memory.limit(x);\n                       calculate(x);\n                       present.byteRetrievedFromDataSequence += x;\n                   }else{\n"
    },
    "VUL4J-8": {
      "input": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() && !outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n"
    },
    "VUL4J-10": {
      "input": "private void readItem(ObjectInputStream inputStream)\n        throws IOException, ClassNotFoundException {\n    inputStream.defaultReadObject();\n"
    },
    "VUL4J-12": {
      "input": "private int enlarge(int s, final int z) {\n"
    },
    "VUL4J-18": {
      "input": "public String acquireSendOnPage( HttpServletRequest r )\n{\n"
    },
    "VUL4J-19": {
      "input": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                    DecodingInformation decipherInformation)\n                                    throws IOException\n{\n    if((decipherInformation instanceof CriterionDecodingInformation))\n    {\n        \n        byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n        byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n\n        CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n        String watchword = information.acquireWatchword();\n    \n        boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n        adjustDecipherDescriptiveData(cipherDescriptiveData);\n        \n        if(watchword == null){\n            watchword = \"\";\n        }\n\n        int lexiconSize = 0;\n        if(cipher.acquireEdition() != 1 ){\n            lexiconSize = cipher.acquireSize() / 8;\n        }else{\n            lexiconSize = 5;\n        } \n\n\n        byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);    \n        int lexiconConsent = cipher.acquireConsent();\n        int lexiconAlteration = cipher.acquireAlteration();\n        byte[] ec = null;\n        byte[] pc = null;\n        Charset watchwordCharSet = Charsets.ISO_8859_1;\n\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            watchwordCharSet = Charsets.UTF_8;\n            ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n            pc = cipher.acquireProprietorCipherUniqueIdentifier();\n        }\n        \n        byte[] passwordByteArray = watchword.getBytes(watchwordCharSet);\n        if( !beProprietorWatchword(passwordByteArray, exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n            lexiconConsent, fileIdentifierByte, lexiconAlteration,\n            lexiconSize, cipherDescriptiveData) )\n            {\n                if( !beExploiterWatchword(passwordByteArray, exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                    lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                    lexiconSize, cipherDescriptiveData) )\n                {\n                    throw new IneffectiveWatchwordException(\"Cannot decrypt PDF, the password is incorrect\");\n\n                } else \n                {\n"
    },
    "VUL4J-20": {
      "input": "   public float[] transformToFloatArray()\n   {\n       int length = length();\n       float[] result = new float[length];\n       int j = 0;\n       while( j < length )\n       {\n"
    },
    "VUL4J-22": {
      "input": "public static String getContextPath(HttpServletRequest r) {\n    String circumstancePath = (String) r.getAttribute(ADD_CIRCUMSTANCE_PATH_PROPERTY);\n    circumstancePath = circumstancePath == null? r.getContextPath(): circumstancePath;\n\n"
    },
    "VUL4J-23": {
      "input": "@Override\npublic String JavaScriptStringEncoding(String dataProvider) {\n    if( dataProvider != null ){\n"
    },
    "VUL4J-25": {
      "input": "@Override\n@Nonnull\npublic String acquireReasonableHref(final String resourseAddress) {\n    if (!StringUtils.isNotEmpty(resourseAddress)) {\n        return \"\";\n    }\n\n"
    },
    "VUL4J-26": {
      "input": "public String acquireUrlRegularExpression() {\n  if (!StringUtils.isNotEmpty(urlRegularExpressionExpr)) {\n    if (!StringUtils.isNotEmpty(urlRegularExpression)) {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n            \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n            \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n            \"@)?(#?\" +\n            \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n            \"[a-z][a-z0-9-]*[a-z0-9]\" +\n            \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n            \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n            \")(:\\\\d+)?\" +\n"
    },
    "VUL4J-30": {
      "input": "public void approve(Object item) throws ValidationException {\n    String attributeTitle = acquireAttributeTitle();\n    Object content = this.acquireAttributeContent(attributeTitle, item);\n    if (content != null && content.toString().length() != 0) {\n        Class content_class = content.getClass();\n        String urlRegex = acquireUrlRegularExpression();\n        Pattern p = Pattern.compile(urlRegex, Pattern.CASE_INSENSITIVE);\n"
    },
    "VUL4J-39": {
      "input": "@Override\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n   \n    s= source != null? s.append(\"remoteAddress=\").append(source):s;\n  \n    if (customerIdentification != null) {\n        \n        s =s.length() > 0?s.append(\", \"):s;\n        s.append(\"clientId=\");\n        s.append(customerIdentification);\n    }\n"
    },
    "VUL4J-40": {
      "input": "   public boolean whetherPermitted(HttpServletRequest request) throws IOException {\n       BufferedReader reader = request.getReader();\n       Customer CustomerOfRequest = JsonTools.retrieveContent(IOUtils.toString(reader), Customer.class);\n       String pathInfo = URLTools.acquireRequestPath(request);\n       IdentityZone zone = IndividualityAreaPossessor.acquire();\n       Customer CustomerOfDatabase;\n       try {\n           CustomerOfDatabase = CustomerManagement.recover(\n               URLTools.derivePathObjectFromURL(CUSTOMER_IDENTIFICATION_PATH_ARGUMENT_INDEX, pathInfo), zone.acquireIdentification());\n       } catch (DataSourceUnfoundException x) {\n           return true;\n       }\n       String dbEmail = CustomerOfDatabase.acquireMainEmail();\n       String requestEmail = CustomerOfRequest.acquireMainEmail();\n       if (dbEmail.equals(requestEmail)) {\n           String dbUserName = CustomerOfDatabase.acquireCustomerTitle();\n           String requestUserName = CustomerOfRequest.acquireCustomerTitle();\n"
    },
    "VUL4J-41": {
      "input": "   protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence,\n                               final String itemTitle, final Date itemTime, final boolean whetherFolder,\n                               final Integer setting, String symbolicLinkTargetLocation )\n       throws IOException, DocumentorException\n   {\n      \n       final File targetFile = FileUtils.resolveFile( folder, itemTitle );\n"
    },
    "VUL4J-43": {
      "input": "public static void saveItem(ZipFile compressedFile, ZipEntry item, File targetFolder)\n\tthrows IOException\n{\n\tString entryName = item.getName();\n\tFile outputFile = new File(targetFolder,entryName);\n"
    },
    "VUL4J-44": {
      "input": "public String convertChar( char[] exempt, Character a )\n{\n\tchar charValue = a.charValue();\n\tString charString = String.valueOf(charValue);\n"
    },
    "VUL4J-46": {
      "input": "   protected XmlManufactory(ObjectCodec objcodec, int xpCharacteristics, int xgCharacteristics,\n           XMLInputFactory xmlInput, XMLOutputFactory xmlOutput,\n           String textComponentName)\n   {\n       super(objcodec);\n       if (xmlOutput == null) {\n           xmlOutput =  XMLOutputFactory.newInstance();\n       }\n       xmlCreatorCharacteristics = xgCharacteristics;\n      \n       if (xmlInput == null) {\n"
    },
    "VUL4J-47": {
      "input": "protected XmlManufactory(ObjectCodec objcodec, int xpCharacteristics, int xgCharacteristics,\n        XMLInputFactory xmlInput, XMLOutputFactory xmlOutput,\n        String textComponentName)\n{\n    super(objcodec);\n    if (xmlOutput == null) {\n        xmlOutput = XMLOutputFactory.newInstance();\n    }\n    \n    xmlCreatorCharacteristics = xgCharacteristics;\n    \n    if (xmlInput == null) {\n        xmlInput = XMLInputFactory.newInstance();\n        xmlInput.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n"
    },
    "VUL4J-50": {
      "input": "private void composeSession(SessionData session, boolean showExploiter) throws IOException {\n\tfinal String sessionId = session.acquireId();\n\tfinal String offSiteControlLocation = session.obtainOffSiteLocation();\n\tcompose(\"<td><a href='?part=sessions&amp;sessionId=\");\n\tString sessionIdHtmlEncode=htmlEnocdeWithoutSpace(sessionId);\n\tcompose(sessionIdHtmlEncode);\n\tcompose(\"'>\");\n\tcompose(sessionIdHtmlEncode);\n\tcompose(\"</a>\");\n\tfinal String followingColumnAlignRightField = \"</td><td align='right'>\";\n\tcompose(followingColumnAlignRightField);\n\tString lastAccess = timeSpanFormatting.format(session.acquireFinalAccess());\n\tString age = timeSpanFormatting.format(session.acquireHistoricPeriod());\n\tString exprDate = terminationFormatting.format(session.acquireTerminationTime());\n\tString attrCount = wholeNumberFormatting.format(session.acquirePropertyCounting());\n\tString serializedSize = wholeNumberFormatting.format(session.acquireSerializedSize());\n\tcompose(lastAccess);\n\tcompose(followingColumnAlignRightField);\n\tcompose(age);\n\tcompose(followingColumnAlignRightField);\n\tcompose(exprDate);\n\tcompose(followingColumnAlignRightField);\n\tcompose(attrCount);\n\tfinal String followingColumnAlignCore = \"</td><td align='center'>\";\n\tfinal String followingColumn = \"</td><td>\";\n\tcompose(followingColumnAlignCore);\n\tString s1 = !session.whetherSerializable()? \"<span class='severe'>#non#</span>\": \"#oui#\";\n\tcompose(s1);\n\tcompose(followingColumnAlignRightField);\n\tcompose(serializedSize);\n\tcompose(followingColumn);\n"
    },
    "VUL4J-53": {
      "input": "void changeTo(Calendar z, int m) {\n"
    },
    "VUL4J-55": {
      "input": "public Calendar roundUp(Calendar calendar) {\n    Calendar futurityTwoYears = (Calendar) calendar.clone();\n    futurityTwoYears.add(Calendar.YEAR, 2);\n    EXTERIOR:\n    while (true) {\n        if (calendar.compareTo(futurityTwoYears) <= 0) {\n            int i =0;\n            while (i< CalendarAttribute.ADJUST_ORDER.length) {\n                CalendarAttribute a = CalendarAttribute.ADJUST_ORDER[i++];\n                int now = a.valueOf(calendar);\n                int following = a.roundUp(this,now);\n                if (now==following)  continue;   \n\n                CalendarAttribute b=a.lowerAttribute;\n                while (b!=null){\n                    b.empty(calendar);\n                    b=b.lowerAttribute;\n                }\n\n                if (following>=0) {\n                    a.changeTO(calendar,following);\n"
    },
    "VUL4J-57": {
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override\npublic boolean beginning() throws Exception {\n    String occupation = measure.acquireOccupation();\n    Point point = Jenkins.getActiveInstance().getItem(occupation, raiseTally.getParent(), Point.class);\n    if (point != null) {\n"
    },
    "VUL4J-59": {
      "input": "      void retrieve(Lexer s, CharScanner m) {\n           char a = m.devour();\n           if(a== endOfFile){\n               s.endOfFileError(this);\n"
    },
    "VUL4J-61": {
      "input": "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n"
    },
    "VUL4J-64": {
      "input": "  final static private XMLStreamReader createXMLStreamReader(InputStream inDataSequence) throws XMLStreamException, IOException {\n      XMLInputFactory producer = XMLInputFactory.newInstance();\n      producer.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n      producer.setProperty(XMLInputFactory.IS_COALESCING, true);\n"
    },
    "VUL4J-65": {
      "input": "   static public File apportionFile(File folder, String titile) {\n       int m = titile.indexOf('?');\n       titile = m > 0? titile.substring(0, m):titile;\n   \n       int point = titile.indexOf('.');\n       String beginning;\n       String postfix;\n       if(point >= 0){\n           beginning  =  titile.substring(0, point);\n           postfix = titile.substring(point);\n       }else{\n           beginning = titile;\n           postfix = \"\";\n       }\n       \n       File f = new File(folder, titile);\n"
    },
    "VUL4J-66": {
      "input": "protected static boolean whetherReasonable(String a)\n{\n   if (a != null && a.length() != 0){\n      int m =0;\n      while(m < a.length()) {\n         char c = a.charAt(m);\n         m++;\n"
    },
    "VUL4J-73": {
      "input": "public boolean isSoundWatchword(String encipheredWatchword, String unprocessedWatchword, Object randomData) {\n"
    },
    "VUL4J-74": {
      "input": "public SecureRandom acquireItem() throws Exception {\n\tSecureRandom secureRandomInstance = SecureRandom.getInstance(algorithm);\n\n"
    }
  }
}