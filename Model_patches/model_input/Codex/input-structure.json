{
  "config": "INSERTION_CODEX_MULTILINE_COMMENT",
  "data": {
    "Netty-1": {
      "prefix": "// Java \n   private void splitHeader(AppendableCharSequence sb) {\n       final int length = sb.length();\n       int nameStart;\n       int nameEnd;\n      \n       nameStart = findNonWhitespace(sb, 0);\n       nameEnd = nameStart;\n       while( nameEnd < length) {\n           char ch = sb.charAtUnsafe(nameEnd);\n           /* BUG: \n            * if (ch != ':' && !Character.isWhitespace(ch)) {\n            * FIXED: \n            */\n",
      "suffix": "               nameEnd ++;\n           }else{\n               break;\n           }\n          \n       }\n       int colonEnd;\n       colonEnd = nameEnd;\n       while ( colonEnd < length) {\n           if (sb.charAtUnsafe(colonEnd) != ':') {\n               colonEnd ++;\n               \n           }else{\n               colonEnd ++;\n               break;\n           }\n           \n       }\n       int valueStart;\n       int valueEnd;\n       name = sb.subStringUnsafe(nameStart, nameEnd);\n       valueStart = findNonWhitespace(sb, colonEnd);\n      if (valueStart != length) {\n           valueEnd = findEndOfString(sb);\n           value = sb.subStringUnsafe(valueStart, valueEnd);\n       } else{\n           value = EMPTY_VALUE;\n       }\n   }\n"
    },
    "Netty-2": {
      "prefix": "// Java \n   private void splitHeader(AppendableCharSequence sb) {\n       final int length = sb.length();\n       int nameStart;\n       int nameEnd;\n      \n       nameStart = findNonWhitespace(sb, 0);\n       nameEnd = nameStart;\n       while( nameEnd < length) {\n           char ch = sb.charAtUnsafe(nameEnd);\n           if (ch != ':' && (isDecodingRequest() || !Character.isWhitespace(ch))) {\n               nameEnd ++;\n           }else{\n               break;\n           }\n          \n       }\n       /* BUG: \n        * int colonEnd;\n        * FIXED: \n        */\n",
      "suffix": "       colonEnd = nameEnd;\n       while ( colonEnd < length) {\n           if (sb.charAtUnsafe(colonEnd) != ':') {\n               colonEnd ++;\n               \n           }else{\n               colonEnd ++;\n               break;\n           }\n           \n       }\n       int valueStart;\n       int valueEnd;\n       name = sb.subStringUnsafe(nameStart, nameEnd);\n       valueStart = findNonWhitespace(sb, colonEnd);\n       if (valueStart != length) {\n           valueEnd = findEndOfString(sb);\n           value = sb.subStringUnsafe(valueStart, valueEnd);\n       } else{\n           value = EMPTY_VALUE;\n       }\n   }\n"
    },
    "Jenkins-1": {
      "prefix": "// Java \n@Exported(inline=true)\npublic Map<String,Object> getMonitorData() { \n    List<NodeMonitor> nodeMonitorList = NodeMonitor.getAll();\n    Map<String,Object> r = new HashMap<String, Object>();\n    int i = 0;\n    /* BUG: \n     * while(i < nodeMonitorList.size() ){\n     *     NodeMonitor monitor = nodeMonitorList.get(i);\n     *     Class monitorClass = monitor.getClass();\n     *     String name  = monitorClass.getName();\n     *     r.put( name ,monitor.data(this));\n     *     i++;\n     * }\n     * FIXED: \n     */\n",
      "suffix": "    return r;\n}\n"
    },
    "Jenkins-2": {
      "prefix": "// Java \n@Exported(name=\"jobs\")\npublic List<TopLevelItem> getItems() {\n    Collection<TopLevelItem> itemValues = items.values();\n    /* BUG: \n     * if (!(authorizationStrategy instanceof AuthorizationStrategy.Unsecured) &&\n     *     !(authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy)) {\n     *     List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n     *     Iterator<TopLevelItem> iterator = itemValues.iterator();\n     *     while( iterator.hasNext()){\n     *         TopLevelItem item = iterator.next();\n     *         if (!item.hasPermission(Item.READ))\n     *             continue;\n     *         viewableItems.add(item);\n     *     }\n     *     return viewableItems;\n     * }\n     * return new ArrayList(itemValues);\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "Jenkins-3": {
      "prefix": "// Java \n   @Override\n   public SearchIndexBuilder makeSearchIndex() {\n       SearchIndexBuilder searchIndexBuilder = super.makeSearchIndex();\n       CollectionSearchIndex<TopLevelItem> collectionSearchIndexItem=new CollectionSearchIndex<TopLevelItem>() {\n               protected SearchItem get(String key) { \n                   return getItemByFullName(key, TopLevelItem.class); \n               }\n               protected Collection<TopLevelItem> all() { \n                   return getAllItems(TopLevelItem.class); \n               }\n       };\n       CollectionSearchIndex collectionSearchIndexComputer = new CollectionSearchIndex() {\n               protected Collection<Computer> all() { \n                   return computers.values(); \n               }\n               protected Computer get(String key) { \n                   return getComputer(key); \n               }\n       };\n       searchIndexBuilder.add(collectionSearchIndexItem);\n       searchIndexBuilder.add(\"configure\", \"config\",\"configure\");\n       View primaryView_ = getPrimaryView();\n       SearchIndexBuilder primaryViewSearchIndexBuilder = primaryView_.makeSearchIndex();\n       searchIndexBuilder.add(primaryViewSearchIndexBuilder);\n       searchIndexBuilder.add(collectionSearchIndexComputer); \n       searchIndexBuilder.add(\"manage\");\n       searchIndexBuilder.add(\"log\");\n        CollectionSearchIndex collectionSearchIndexView = new CollectionSearchIndex() {\n               /* BUG: \n                * protected Collection<View> all() { \n                *     return views; \n                * }\n                * FIXED: \n                */\n",
      "suffix": "               protected View get(String key) { \n                   return getView(key); \n               }\n           };\n          CollectionSearchIndex collectionSearchIndexUser = new CollectionSearchIndex() {\n               protected Collection<User> all() { \n                   return User.getAll(); \n               }\n               protected User get(String key) { \n                   return User.get(key,false); \n               }\n               \n           };\n           \n       searchIndexBuilder.add(collectionSearchIndexUser);\n           \n       searchIndexBuilder.add(collectionSearchIndexView);\n       return searchIndexBuilder;\n           \n       \n   }"
    },
    "Jinjava-1": {
      "prefix": "// Java \nprivate static final Set<String> RESTRICTED_METHODS = ImmutableSet.<String> builder()\n    .add(\"clone\")\n    .add(\"wait\")\n    /* BUG: \n     * .add(\"notify\")\n     * FIXED: \n     */\n",
      "suffix": "    .add(\"hashCode\")\n    .add(\"notifyAll\")\n    .build();"
    },
    "Halo-1": {
      "prefix": "// Java \npublic static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n    Assert.notNull(pathToCheck, \"Path to check must not be null\");\n    Assert.notNull(parentPath, \"Parent path must not be null\");\n    \n    Path normalizedParentPath = parentPath.normalize();\n    /* BUG: \n     * if (!pathToCheck.startsWith(normalizedParentPath)) {\n     * FIXED: \n     */\n",
      "suffix": "        ForbiddenException e =  new ForbiddenException(\"You do not have permission to access \" + pathToCheck);\n        e.setErrorData(pathToCheck);\n        throw e;\n    }\n\n}"
    },
    "Retrofit-1": {
      "prefix": "// Java \nJaxbResponseConverter(JAXBContext context, Class<T> type) {\n  this.type = type;\n  /* BUG: \n   * this.context = context;\n   * FIXED: \n   */\n",
      "suffix": "}"
    },
    "Quartz-1": {
      "prefix": "// Java \n   protected void initDocumentParser() throws ParserConfigurationException  {\n       Object source = resolveSchemaSource();\n       DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n       docBuilderFactory.setValidating(true);\n       docBuilderFactory.setNamespaceAware(true);\n       \n       docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n       docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", source);\n       \n       /* BUG: \n        * docBuilder = docBuilderFactory.newDocumentBuilder();\n        * FIXED: \n        */\n",
      "suffix": "       \n       docBuilder.setErrorHandler(this);\n       \n       NamespaceContext nsContext = new NamespaceContext()\n       {\n           public String getPrefix(String namespaceURI)\n         {\n             throw new UnsupportedOperationException();\n         }\n         public String getNamespaceURI(String prefix)\n         {\n               if (prefix != null){\n                   switch(prefix){\n                       case XMLConstants.XML_NS_PREFIX:\n                           return XMLConstants.XML_NS_URI;\n                       case \"q\":\n                           return QUARTZ_NS;\n                       case XMLConstants.XMLNS_ATTRIBUTE:\n                           return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n                       default:\n                           break;\n                   }\n                   return XMLConstants.NULL_NS_URI;\n               }else{\n                   throw new IllegalArgumentException(\"Null prefix\");\n               }\n         }\n       \n         public Iterator<?> getPrefixes(String namespaceURI)\n         {\n             throw new UnsupportedOperationException();\n         }\n       \n       }; \n       \n       XPathFactory xpathFactory = XPathFactory.newInstance();\n       xpath = xpathFactory.newXPath();\n       xpath.setNamespaceContext(nsContext);\n   }\n"
    },
    "Flow-1": {
      "prefix": "// Java \n   public boolean serveDevModeRequest(HttpServletRequest request,\n           HttpServletResponse response) throws IOException {\n   \n       if ( !isDevServerFailedToStart.get() && devServerStartFuture.isDone()) {\n           String requestFilename = request.getPathInfo();\n           /* BUG: \n            * if (!HandlerHelper.isPathUnsafe(requestFilename)) {\n            * FIXED: \n            */\n",
      "suffix": "     \n               requestFilename = APP_THEME_PATTERN.matcher(requestFilename).find()? \"/VAADIN/static\" + requestFilename:requestFilename;\n               String requestMethodname = request.getMethod();\n               HttpURLConnection connection = prepareConnection(requestFilename,\n                       requestMethodname);\n               \n               for (Enumeration<String> headerNames = request.getHeaderNames(); headerNames.hasMoreElements(); ) {\n                   String header = headerNames.nextElement();\n                   String value = \"Connect\".equals(header) ? \"close\": request.getHeader(header);\n                   connection.setRequestProperty(header, value);\n               }\n               getLogger().debug(\"Requesting resource to webpack {}\",\n                       connection.getURL());\n               int responseCode = connection.getResponseCode();\n               if (responseCode != HTTP_NOT_FOUND) {\n                   getLogger().debug(\"Served resource by webpack: {} {}\", responseCode,\n                           requestFilename);\n                   connection.getHeaderFields().forEach((header, values) -> {\n                       if (header != null) {\n                           response.addHeader(header, values.get(0));\n                       }\n                   });\n                   if (responseCode != HTTP_OK) {\n                       \n                       if(responseCode >= 400){\n                           response.sendError(responseCode);\n                       }else{\n                           response.setStatus(responseCode);\n                       }\n               \n                   } else {\n                       writeStream(response.getOutputStream(),\n                       connection.getInputStream());\n                   }\n                   response.getOutputStream().close();\n                   return true;\n                   \n             \n               }else{\n                   getLogger().debug(\"Resource not served by webpack {}\",\n                           requestFilename);\n                   return false;\n               }\n           }else{\n               getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,requestFilename);\n               response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n               return true;\n           }\n           \n       }else{\n           return false;\n       }\n       \n   }\n"
    },
    "Flow-2": {
      "prefix": "// Java \n   @Override\n   public int setErrorParameter(BeforeEnterEvent event,\n           ErrorParameter<NotFoundException> parameter) {\n       \n       String additionalInfo = parameter.hasCustomMessage()? \"Reason: \" + parameter.getCustomMessage():\"\";\n       Location location = event.getLocation();\n       String path = location.getPath();\n       path = Jsoup.clean(path, Whitelist.none());\n       additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n       UI ui = event.getUI();\n       VaadinSession session = ui.getSession();\n       DeploymentConfiguration config = session.getConfiguration();\n       boolean productionMode = config.isProductionMode();\n       String template = getErrorHtml(productionMode);\n       /* BUG: \n        * template = template.replace(\"{{path}}\", path);\n        * template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n        * String routes = getRoutes(event);\n        * template = template.contains(\"{{routes}}\")? template.replace(\"{{routes}}\", routes): template;\n        * FIXED: \n        */\n",
      "suffix": "       \n       com.vaadin.flow.dom.Element element = getElement();\n       Html html = new Html(template);\n       element.appendChild(html.getElement());\n       return HttpServletResponse.SC_NOT_FOUND;\n   }\n"
    },
    "BC-Java-1": {
      "prefix": "// Java \nprivate BigInteger[] derDecode(\n    byte[]  encoding)\n    throws IOException\n{\n    ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n    /* BUG: \n     * ASN1Encodable object0 = s.getObjectAt(0);\n     * FIXED: \n     */\n",
      "suffix": "    BigInteger bigInteger0 = ((ASN1Integer) object0).getValue();\n    ASN1Encodable object1 = s.getObjectAt(1);\n    BigInteger bigInteger1 = ((ASN1Integer) object1).getValue();\n    return new BigInteger[]{\n        bigInteger0,\n        bigInteger1\n    };\n}"
    },
    "Json-sanitizer-1": {
      "prefix": "// Java \n private void sanitizeString(int start, int end) {\n   boolean closed = false;\n   int i = start;\n   while ( i < end) {\n     char ch = jsonish.charAt(i);\n       if(ch== '\\u2028'){ replace(i, i + 1, \"\\\\u2028\"); }\n       else if( ch=='\"'|| ch== '\\''){\n         if (i != start) {\n           if (i + 1 == end) {\n             char startDelim = jsonish.charAt(start);\n             if (startDelim != '\\'') {\n               startDelim = '\"';\n             }\n             closed = startDelim == ch;\n           }\n           \n           if(!closed){\n             if(ch == '\"'){\n               insert(i, '\\\\');\n             }\n           }else{\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n           }\n          \n         } else {\n           if (ch == '\\'') { replace(i, i + 1, '\"'); }\n         }\n       }\n       /* BUG: \n        * else if(ch== '/'){\n        *   if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n        *       && 's' == (jsonish.charAt(i + 1) | 32)\n        *       && 'c' == (jsonish.charAt(i + 2) | 32)) {\n        *     insert(i, '\\\\');\n        *   }\n        * }\n        * FIXED: \n        */\n",
      "suffix": "       else if(ch=='\\r'){ replace(i, i + 1, \"\\\\r\");}\n       else if(ch=='\\u2029'){ replace(i, i + 1, \"\\\\u2029\"); }\n       else if(ch== '\\\\'){\n         if (i + 1 != end) {\n           char sch = jsonish.charAt(i + 1);\n           if( sch =='b'||sch == 'f'|| sch == 'n'||sch =='r'||sch == 't'||sch == '\\\\'||\n           sch == '/'|| sch == '\"'){\n             ++i;\n           }\n           else if( sch == 'v'){  \n             replace(i, i + 2, \"\\\\u0008\");\n             ++i;\n           }\n           else if( sch == 'x'){\n             if (i + 4 >= end || !isHexAt(i+2) || !isHexAt(i+3)) {\n               elide(i, i + 1);\n             }else{\n               replace(i, i + 2, \"\\\\u00\");  \n               i += 3;\n             }\n           }\n           else if( sch == 'u'){\n             if (i + 6 >= end || !isHexAt(i + 2) || !isHexAt(i + 3)\n                 || !isHexAt(i + 4) || !isHexAt(i + 5)) {\n               elide(i, i + 1);\n             }else{\n               i += 5;\n             }\n           }\n           else if( sch == '0'|| sch == '1'|| sch == '2'|| sch == '3'||\n           sch == '4'||sch == '5'|| sch == '6'|| sch == '7'){\n             int octalEnd = i + 1;\n             if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n               ++octalEnd;\n               if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                 ++octalEnd;\n               }\n               int value = 0;\n               int j = i;\n               while ( j < octalEnd) {\n                 value = (value << 3) | (jsonish.charAt(j) - '0');\n                 j++;\n               }\n               replace(i + 1, octalEnd, \"u00\");\n               appendHex(value, 2);\n             }\n             i = octalEnd - 1;\n           }else{\n             elide(i, i + 1);\n           }\n         }else{\n            elide(i, i + 1);\n           i++;\n           continue;\n         }\n       \n         \n       } else if(ch==  ']'){\n         if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n             && '>' == jsonish.charAt(i + 2)) {\n           replace(i, i + 1, \"\\\\u005d\");\n         }\n       }else if(ch== '\\n'){ \n         replace(i, i + 1, \"\\\\n\");\n       }\n       else{\n         if (ch >= 0x20) {\n           if (ch >= 0xd800) {  \n             if (ch >= 0xe000) { \n                 if (ch <= 0xfffd) { \n                       i++;\n                       continue;\n                     }\n             } else{\n               if (Character.isHighSurrogate(ch) && i+1 < end\n                   && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n                 ++i; \n                 i++;\n                 continue;\n               }\n             }\n             \n           } else{\n             i++;\n             continue;\n           }\n           \n         }else{\n           if (ch == 9 || ch == 0xa || ch == 0xd) { i++;continue; }\n         }\n         \n         replace(i, i + 1, \"\\\\u\");\n         int j = 4;\n         while ( --j >= 0) {\n           sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n         }\n       }\n     \n     i++;\n   }\n   if (closed) {\n     return;\n   }else{ \n     insert(end, '\"'); \n   }\n }"
    },
    "Ratpack-1": {
      "prefix": "// Java \nprivate void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n   DecoderResult decoderResult = nettyRequest.decoderResult();\n   if (decoderResult.isSuccess()) {\n     HttpHeaders httpHeaders = nettyRequest.headers();\n     Headers requestHeaders = new NettyHeadersBackedHeaders(httpHeaders);\n     Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n     boolean hasBody = (contentLength > 0) || (requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING) != null);\n     RequestBody requestBody;\n     if(!hasBody){\n       requestBody =  null;\n     }else{\n       requestBody  = new RequestBody(contentLength, nettyRequest, ctx);\n     }\n   \n     Channel channel = ctx.channel();\n     if (requestBody != null) {\n       channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n     }\n     X509Certificate clientCertificate = channel.attr(CLIENT_CERT_KEY).get();\n     Instant instant = clock.instant();\n     DefaultRequest request = new DefaultRequest(\n       instant,\n       requestHeaders,\n       nettyRequest.method(),\n       nettyRequest.protocolVersion(),\n       nettyRequest.uri(),\n       (InetSocketAddress) channel.remoteAddress(),\n       (InetSocketAddress) channel.localAddress(),\n       serverRegistry.get(ServerConfig.class),\n       requestBody,\n       ConnectionIdleTimeout.of(channel),\n       clientCertificate\n     );\n     /* BUG: \n      * HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n      * FIXED: \n      */\n",
      "suffix": "     MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n     AtomicBoolean transmitted = new AtomicBoolean(false);\n     DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n     Channel ctxChannel = ctx.channel();\n     ctxChannel.attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n     DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n       applicationConstants,\n       request,\n       channel,\n       responseTransmitter,\n       thing -> {\n       transmitted.set(true);\n       ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n     }\n     );\n     ByteBufAllocator byteBufAllocator =  ctx.alloc();\n     Response response = new DefaultResponse(responseHeaders, byteBufAllocator, responseTransmitter);\n     requestConstants.response = response;\n     EventLoop eventLoop = channel.eventLoop();\n     DefaultContext.start(eventLoop, requestConstants, serverRegistry, handlers, execution -> {\n       if (!transmitted.get()) {\n         Handler lastHandler = requestConstants.handler;\n         StringBuilder description = new StringBuilder();\n         description.append(\"No response sent for \");\n         String name = request.getMethod().getName();\n         description.append(name);\n         description.append(\" request to \");\n         String uri = request.getUri();\n         description.append(uri);\n         if (lastHandler != null) {\n           description.append(\" (last handler: \");\n           if (!(lastHandler instanceof DescribingHandler)) {\n             DescribingHandlers.describeTo(lastHandler, description);\n           } else {\n             ((DescribingHandler) lastHandler).describeTo(description);\n           }\n           description.append(\")\");\n         }\n         String message = description.toString();\n         LOGGER.warn(message);\n         response.getHeaders().clear();\n         ByteBuf body;\n         if (!development) {\n           body = Unpooled.EMPTY_BUFFER;\n         } else {\n           ByteBufAllocator byteBufAllocator2 =  ctx.alloc();\n           CharBuffer charBuffer =  CharBuffer.wrap(message);\n           body = ByteBufUtil.encodeString(byteBufAllocator2, charBuffer, CharsetUtil.UTF_8);\n           response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n         }\n         int num = body.readableBytes();\n         response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, num);\n         responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n       }\n     });\n  \n   }else{\n     LOGGER.debug(\"Failed to decode HTTP request.\", decoderResult.cause());\n     sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n     return;\n   }\n }"
    },
    "Pulsar-1": {
      "prefix": "// Java \n   protected void internalGetMessageById(AsyncResponse asyncResponse, long ledgerId, long entryId,\n                                             boolean authoritative) {\n       try {\n           validateTopicOwnership(topicName, authoritative);\n           validateTopicOperation(topicName, TopicOperation.PEEK_MESSAGES);\n           if (topicName.isGlobal()) {\n               validateGlobalNamespaceOwnership(namespaceName);\n           }\n           AsyncCallbacks.ReadEntryCallback readEntryCallback = new AsyncCallbacks.ReadEntryCallback() {\n               @Override\n               public void readEntryComplete(Entry entry, Object ctx) {\n                   try {\n                       Response response = generateResponseWithEntry(entry);\n                       asyncResponse.resume(response);\n                   } catch (IOException exception) {\n                       RestException restException =  new RestException(exception);\n                       asyncResponse.resume(restException);\n                   } finally {\n                       if (entry == null) {\n                           return;\n                       }else{\n                           entry.release();\n                       }\n                   }\n               }\n               @Override\n               public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n                   RestException restException =  new RestException(exception);\n                   asyncResponse.resume(restException);\n               }\n           };\n           PositionImpl positionImpl = new PositionImpl(ledgerId, entryId);\n           /* BUG: \n            * ((ManagedLedgerImpl) ((PersistentTopic) getTopicReference(topicName)).getManagedLedger())\n            * FIXED: \n            */\n",
      "suffix": "               .asyncReadEntry(positionImpl,readEntryCallback , null);\n       } catch (NullPointerException npe) {\n           RestException restException =  new RestException(Status.NOT_FOUND, \"Message not found\");\n           asyncResponse.resume(restException);\n       } catch (Exception exception) {\n           String id = clientAppId();\n           log.error(\"[{}] Failed to get message with ledgerId {} entryId {} from {}\",\n                   id , ledgerId, entryId, topicName, exception);\n           RestException restException =  new RestException(exception);\n           asyncResponse.resume(restException);\n       }\n   }\n"
    },
    "VUL4J-1": {
      "prefix": "// Java \n   @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n   public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n       final JSONLexer lexer = parser.lexer;\n       switch (lexer.token()) {\n           case JSONToken.LITERAL_STRING:\n               byte[] bytes = lexer.bytesValue();\n               lexer.nextToken(JSONToken.COMMA);\n               return (T) bytes;\n           case JSONToken.NULL:\n               lexer.nextToken(JSONToken.COMMA);\n               return null;\n           default:\n               break;\n       }\n       JSONArray array = new JSONArray();\n       Class componentClass;\n       Type componentType;\n       if (!(type instanceof GenericArrayType)) {\n           componentType =  ((Class) type).getComponentType();\n           componentClass = ((Class) type).getComponentType();\n       } else {\n           componentType = ((GenericArrayType) type).getGenericComponentType();\n           if (! (componentType instanceof TypeVariable)) {\n               componentClass = TypeUtils.getClass(componentType);\n           } else {\n                  \n               TypeVariable typeVar = (TypeVariable) componentType;\n               Type objType = parser.getContext().type;\n               if (!(objType instanceof ParameterizedType)) {\n                   Type type_ = typeVar.getBounds()[0];\n                   componentClass = TypeUtils.getClass(type_);\n             \n               } else {\n         \n                   ParameterizedType objParamType = (ParameterizedType) objType;\n                   Type objRawType = objParamType.getRawType();\n                   Type actualType = null;\n                   if (objRawType instanceof Class) {\n                       TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\n                       int i = 0;\n                       while( i < objTypeParams.length) {\n                           String i_name = objTypeParams[i].getName();\n                           String typeVar_name = typeVar.getName();\n                           if (!i_name.equals(typeVar_name)) {\n                               i++;\n                              continue;\n                           }\n                           actualType = objParamType.getActualTypeArguments()[i];\n                           i++;\n                       }\n                   }\n                   \n                   componentClass = (actualType instanceof Class)? (Class) actualType:Object.class;\n               } \n           }\n       }\n       /* BUG: \n        * parser.parseArray(componentClass, array, fieldName);\n        * FIXED: \n        */\n",
      "suffix": "       \n       return (T) toObjectArray(parser, componentClass, array);\n   }\n"
    },
    "VUL4J-3": {
      "prefix": "// Java \n@Converter\npublic SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n    XMLReader xmlReader = null;\n    SAXParserFactory sfactory = null;\n    \n    try {\n        if (!(exchange == null)) {\n            sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n        }\n\n        if (sfactory != null) {\n            sfactory.setNamespaceAware(true);\n            xmlReader = sfactory.newSAXParser().getXMLReader();\n        }else{\n            sfactory = SAXParserFactory.newInstance();\n            try {\n                sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            } catch (Exception e) {\n                LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n            }\n            /* BUG: \n             * sfactory.setNamespaceAware(true);\n             * FIXED: \n             */\n",
      "suffix": "            xmlReader = sfactory.newSAXParser().getXMLReader();\n        }\n    \n    } catch (Exception ex) {\n        LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n    }\n    Reader reader = source.getReader();\n    InputSource inputSource = reader == null? new InputSource(source.getInputStream()):new InputSource(reader);\n    String systemId = source.getSystemId();\n    inputSource.setSystemId(systemId);\n    String publicId = source.getPublicId();\n    inputSource.setPublicId(publicId);\n\n    return new SAXSource(xmlReader, inputSource);\n}"
    },
    "VUL4J-4": {
      "prefix": "// Java \nprotected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n    if (body != null) {\n\n        Class<?> type = getDocumentType();\n        Exception cause = null;\n        Object answer = null;\n\n        if (type != null) {\n            try {\n                CamelContext context = exchange.getContext();\n                TypeConverter typeConverter = context.getTypeConverter();\n                answer = typeConverter.convertTo(type, exchange, body);\n            } catch (Exception e) {\n                cause = e;\n            }\n        }\n\n        /* BUG: \n         * if (answer == null) {\n         *     if (!(body instanceof WrappedFile)) {\n         *         if (!(body instanceof BeanInvocation)) {\n         *             if (body instanceof String) {\n         *                 StringReader stringReader = new StringReader((String) body);\n         *                 answer = new InputSource(stringReader);\n         *             }\n         *         }else{\n         *             CamelContext context = exchange.getContext();\n         *             TypeConverter typeConverter = context.getTypeConverter();\n         *             BeanInvocation bi = typeConverter.convertTo(BeanInvocation.class, exchange, body);\n         *             if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {\n         *                 answer = null;\n         *             }\n         *         }\n         *     }else{\n         *         CamelContext context = exchange.getContext();\n         *         TypeConverter typeConverter = context.getTypeConverter();\n         *         answer = new InputSource(typeConverter.convertTo(InputStream.class, exchange, body));\n         *     }\n         * }\n         * FIXED: \n         */\n",
      "suffix": "\n        if (type != null || answer != null) {\n            if (answer == null) {\n                if (cause == null) {\n                    throw new NoTypeConversionAvailableException(body, type);\n                } else {\n                    throw cause;\n                }\n            } \n        }else{\n            answer = body;\n        }   \n        return answer;\n    }\n\n    return null;\n}"
    },
    "VUL4J-5": {
      "prefix": "// Java \n   private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n       throws IOException {\n       for (ArchiveEntry nextEntry = supplier.getNextReadableEntry(); nextEntry != null; nextEntry = supplier.getNextReadableEntry()) {\n           String name = nextEntry.getName();\n           File f = new File(targetDirectory, name);\n           String fpath = f.getCanonicalPath();\n           \n           /* BUG: \n            * if (fpath.startsWith(targetDirectory.getCanonicalPath())) {   \n            * FIXED: \n            */\n",
      "suffix": "               if (!nextEntry.isDirectory()) {\n                   File parent = f.getParentFile();\n                   if (parent.isDirectory() || parent.mkdirs()) {\n                       Path fp = f.toPath();\n                       try (OutputStream o = Files.newOutputStream(fp)) {\n                           writer.writeEntryDataTo(nextEntry, o);\n                       }\n\n                   }else{\n                       String s = \"failed to create directory \" + parent;\n                       throw new IOException(s);\n                   }\n               } else {\n                   if (f.isDirectory() || f.mkdirs()) {\n                       continue;\n                   }else{\n                       String s = \"failed to create directory \" + f;\n                       throw new IOException(s);\n                   }\n               }\n           }else{\n               String s = \"expanding \" + nextEntry.getName()\n               + \" would create file outside of \" + targetDirectory;\n               throw new IOException(s);\n           }\n       }\n   }\n"
    },
    "VUL4J-6": {
      "prefix": "// Java \n public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n       this.rcount = ZipLong.getValue(data, offset + 8);\n       this.flags = ZipShort.getValue(data, offset + 6);\n       this.format = ZipShort.getValue(data, offset);\n       this.bitlen = ZipShort.getValue(data, offset + 4);\n       int zv2 = ZipShort.getValue(data, offset + 2);\n       this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2);\n       if (rcount <= 0) {\n           return;\n       }\n       this.hashSize = ZipShort.getValue(data, offset + 14);\n       int zv12 =  ZipShort.getValue(data, offset + 12);\n       this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12);\n       /* BUG: \n        * int i = 0;\n        * FIXED: \n        */\n",
      "suffix": "       while ( i < this.rcount) {\n           i++;\n           int j = 0;\n           while ( j < this.hashSize) {\n               j++;\n           }\n       }\n   }"
    },
    "VUL4J-7": {
      "prefix": "// Java \n   private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n       if (!current.hasDataDescriptor) {\n           \n           final long csize = current.entry.getSize();\n           if (current.bytesRead < csize) {\n               if (buf.position() >= buf.limit()) {\n                   buf.position(0);\n                   byte[] bufArray = buf.array();\n                   final int l = in.read(bufArray);\n                   if (l != -1) {\n                       buf.limit(l);\n                       count(l);\n                       current.bytesReadFromStream += l;\n                   }else{\n                       /* BUG: \n                        * return -1;\n                        * FIXED: \n                        */\n",
      "suffix": "                   }\n               }\n               int bufRemaining = buf.remaining();\n               int toRead = Math.min(bufRemaining, length);\n               if ((csize - current.bytesRead) < toRead) {\n                   toRead = (int) (csize - current.bytesRead);\n               }\n               buf.get(buffer, offset, toRead);\n               current.bytesRead += toRead;\n               return toRead;\n               \n           }else{\n               return -1;\n           }\n       }else{\n           if (lastStoredEntry == null) {\n               readStoredEntry();\n           }\n           return lastStoredEntry.read(buffer, offset, length);\n       }\n   }\n"
    },
    "VUL4J-8": {
      "prefix": "// Java \n@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() && !res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            /* BUG: \n             * } \n             * FIXED: \n             */\n",
      "suffix": "        }else{\n            int l = 6 * res.length();\n            int spaceForSurrogate = estimateIncrementalEncodingSize(enc,l );\n            if (spaceForSurrogate > out.remaining()) {\n    \n                int charCount = 0;\n                int i = cb.position() ;\n                while ( i < cb.limit() ) {\n                    if(enc.canEncode(cb.get(i))){\n                        charCount +=1;\n                    }else{\n                        charCount +=6;\n                    }\n                    \n                    i++;\n                }\n                int outRemaining = out.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, charCount) - outRemaining);\n            }\n            \n            tmp = tmp == null? CharBuffer.allocate(6):tmp;\n    \n            int i = 0;\n            while ( i < res.length()) {\n                CharBuffer encodeSurrogateCharBuffer = encodeSurrogate(tmp, cb.get());\n                out = encodeFully(enc, encodeSurrogateCharBuffer, out);\n                ++i;\n            }\n        }  \n    }\n\n    enc.encode(cb, out, true);\n    out.limit(out.position());\n    out.rewind();\n    return out;\n}\n"
    },
    "VUL4J-10": {
      "prefix": "// Java \nprivate void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException {\n    in.defaultReadObject();\n    /* BUG: \n     * OutputStream output = getOutputStream();\n     * FIXED: \n     */\n",
      "suffix": "    if (cachedContent == null) {\n        IOUtils.copy(new FileInputStream(dfosFile), output);\n        dfosFile.delete();\n        dfosFile = null;\n    } else {\n        output.write(cachedContent);\n    }\n    output.close();\n\n    cachedContent = null;\n}\n"
    },
    "VUL4J-12": {
      "prefix": "// Java \nprivate int extend(int v, final int t) {\n    /* BUG: \n     * for (int vt = (1 << (t - 1)); v < vt; v += vt) {\n     *     vt = (-1 << t) + 1;\n     * }\n     * FIXED: \n     */\n",
      "suffix": "    return v;\n}"
    },
    "VUL4J-18": {
      "prefix": "// Java \npublic String getForwardPage( HttpServletRequest request )\n{\n    /* BUG: \n     * String pathInfo = request.getPathInfo();\n     * return pathInfo;\n     * FIXED: \n     */\n",
      "suffix": "}\n"
    },
    "VUL4J-19": {
      "prefix": "// Java \n@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        \n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n    \n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        \n        if(password == null){\n            password = \"\";\n        }\n\n        int dicLength = 0;\n        if(encryption.getVersion() != 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n\n\n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        \n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n\n                } else \n                {\n                    /* BUG: \n                     * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                     * FIXED: \n                     */\n",
      "suffix": "                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n\n                if ( dicRevision != 6 && dicRevision != 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n            \n                }\n\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        \n    \n\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n\n        if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n        {\n            return;\n\n        }else{\n\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n\n            if (stdCryptFilterDictionary == null)\n            {\n                return;\n            }\n\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}"
    },
    "VUL4J-20": {
      "prefix": "// Java \n   public float[] toFloatArray()\n   {\n       int size = size();\n       float[] retval = new float[size];\n       int i = 0;\n       while( i < size )\n       {\n           /* BUG: \n            * COSNumber cosNumber = (COSNumber)getObject( i );\n            * retval[i] = cosNumber.floatValue();\n            * FIXED: \n            */\n",
      "suffix": "           i++;\n       }\n       return retval;\n   }"
    },
    "VUL4J-22": {
      "prefix": "// Java \npublic static String getContextPath(HttpServletRequest request) {\n    String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n    contextPath = contextPath == null? request.getContextPath(): contextPath;\n\n    /* BUG: \n     * if (!\"/\".equals(contextPath)) \n     *     return decodeRequestString(request, contextPath);\n     * else\n     *     return decodeRequestString(request, \"\");\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "VUL4J-23": {
      "prefix": "// Java \n@Override\npublic String encodeForJSString(String source) {\n    if( source != null ){\n        /* BUG: \n         * return Encode.forJavaScriptSource(source);\n         * FIXED: \n         */\n",
      "suffix": "    }\n    return null;\n}\n"
    },
    "VUL4J-25": {
      "prefix": "// Java \n@Override\n@Nonnull\npublic String getValidHref(final String url) {\n    if (!StringUtils.isNotEmpty(url)) {\n        return \"\";\n    }\n\n    /* BUG: \n     * try {\n     *     String name = StandardCharsets.UTF_8.name();\n     *     String encodedUrl = StringEscapeUtils.unescapeXml(URLDecoder.decode(url,name));\n     *     encodedUrl = encodedUrl.replaceAll(\"\\\"\", \"%22\");\n     *     encodedUrl = encodedUrl.replaceAll(\"'\", \"%27\");\n     *     encodedUrl = encodedUrl.replaceAll(\">\", \"%3E\");\n     *     encodedUrl = encodedUrl.replaceAll(\"<\", \"%3C\");\n     *     encodedUrl = encodedUrl.replaceAll(\"`\", \"%60\");\n     *     encodedUrl = encodedUrl.replaceAll(\" \", \"%20\");\n     *     int qMarkIx = encodedUrl.indexOf('?');\n     *     encodedUrl = qMarkIx > 0? encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\"):encodedUrl;\n     *     encodedUrl = mangleNamespaces(encodedUrl);\n     *     if (xssFilter.isValidHref(encodedUrl)) {\n     *         return encodedUrl;\n     *     }\n     * } catch (UnsupportedEncodingException e) {\n     *     LOGGER.error(\"Unable to decode url: {}.\", url);\n     * }\n     * FIXED: \n     */\n",
      "suffix": "\n    return \"\";\n}"
    },
    "VUL4J-26": {
      "prefix": "// Java \npublic String getUrlRegex() {\n  if (!StringUtils.isNotEmpty(urlRegexExpression)) {\n    if (!StringUtils.isNotEmpty(urlRegex)) {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n            \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n            \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n            \"@)?(#?\" +\n            \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n            \"[a-z][a-z0-9-]*[a-z0-9]\" +\n            \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n            \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n            \")(:\\\\d+)?\" +\n            /* BUG: \n             * \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n             * FIXED: \n             */\n",
      "suffix": "            \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n            \"?)?)?\" +\n            \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n            \"$\";\n            \n    } else {\n          return urlRegex;\n    }\n  }else{\n    return (String) parse(urlRegexExpression, String.class);\n  }\n}\n"
    },
    "VUL4J-30": {
      "prefix": "// Java \npublic void validate(Object object) throws ValidationException {\n    String fieldName = getFieldName();\n    Object value = this.getFieldValue(fieldName, object);\n    if (value != null && value.toString().length() != 0) {\n        Class value_class = value.getClass();\n        String urlRegex = getUrlRegex();\n        Pattern p = Pattern.compile(urlRegex, Pattern.CASE_INSENSITIVE);\n        /* BUG: \n         * String s = String.valueOf(value);\n         * FIXED: \n         */\n",
      "suffix": "        Matcher m = p.matcher(s);\n        if (value_class.equals(String.class) && m.matches()) {\n            return;\n        }\n        addFieldError(fieldName, object);\n    }\n}\n"
    },
    "VUL4J-39": {
      "prefix": "// Java \n@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n   \n    sb= origin != null? sb.append(\"remoteAddress=\").append(origin):sb;\n  \n    if (clientId != null) {\n        \n        sb =sb.length() > 0?sb.append(\", \"):sb;\n        sb.append(\"clientId=\");\n        sb.append(clientId);\n    }\n    /* BUG: \n     * if (sessionId != null) {\n     *     sb =sb.length() > 0?sb.append(\", \"):sb;\n     *     sb.append(\"sessionId=\");\n     *     sb.append(sessionId);\n     * }\n     * FIXED: \n     */\n",
      "suffix": "    return sb.toString();\n}\n"
    },
    "VUL4J-40": {
      "prefix": "// Java \n   public boolean isAllowed(HttpServletRequest request) throws IOException {\n       BufferedReader reader = request.getReader();\n       ScimUser scimUserFromRequest = JsonUtils.readValue(IOUtils.toString(reader), ScimUser.class);\n       String pathInfo = UaaUrlUtils.getRequestPath(request);\n       IdentityZone zone = IdentityZoneHolder.get();\n       ScimUser scimUserFromDb;\n       try {\n           scimUserFromDb = scimUserProvisioning.retrieve(\n               UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, pathInfo), zone.getId());\n       } catch (ScimResourceNotFoundException e) {\n           return true;\n       }\n       String dbEmail = scimUserFromDb.getPrimaryEmail();\n       String requestEmail = scimUserFromRequest.getPrimaryEmail();\n       if (dbEmail.equals(requestEmail)) {\n           String dbUserName = scimUserFromDb.getUserName();\n           String requestUserName = scimUserFromRequest.getUserName();\n           /* BUG: \n            * if (dbUserName.equals(requestUserName)) {\n            * FIXED: \n            */\n",
      "suffix": "               if (scimUserFromDb.isVerified() == scimUserFromRequest.isVerified()) {\n                   if (scimUserFromDb.isActive() == (scimUserFromRequest.isActive())) {\n                       String dbOrigin = scimUserFromDb.getOrigin();\n                       String requestOrigin = scimUserFromRequest.getOrigin();\n                       if (dbOrigin.equals(requestOrigin)) {\n                           return true;\n                           \n                       }else{\n                           return false;\n                       }\n                       \n                   }else{\n                       return false;\n                   }\n                                       \n               }else{\n                   return false;\n               }\n           }else{\n               return false;\n           }    \n           \n       }else{\n           return false;\n       }\n      \n   }\n"
    },
    "VUL4J-41": {
      "prefix": "// Java \n   protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                               final String entryName, final Date entryDate, final boolean isDirectory,\n                               final Integer mode, String symlinkDestination )\n       throws IOException, ArchiverException\n   {\n      \n       final File f = FileUtils.resolveFile( dir, entryName );\n       /* BUG: \n        * try{\n        * FIXED: \n        */\n",
      "suffix": "           if ( isOverwrite() || !f.exists() ||  f.lastModified() < entryDate.getTime() ) \n           {\n               final File dirF = f.getParentFile();\n               if ( dirF != null )\n               {\n                   dirF.mkdirs();\n               }\n               if ( StringUtils.isEmpty( symlinkDestination ) )\n               {\n       \n                   if (! isDirectory )\n                   {\n                       OutputStream out = null;\n                       try\n                       {\n                           out = new FileOutputStream( f );\n                           IOUtil.copy( compressedInputStream, out );\n                           out.close();\n                           out = null;\n                       }\n                       finally\n                       {\n                           IOUtil.close( out );\n                       }\n                   }\n                   else\n                   {\n                       f.mkdirs();\n                 \n                   }\n               }\n               else{\n                   File symlinkDestFile = new File( symlinkDestination );\n                   SymlinkUtils.createSymbolicLink( f, symlinkDestFile );\n               }\n               \n       \n               long time = entryDate.getTime();\n               f.setLastModified( time );\n               if ( !isIgnorePermissions() && mode != null && !isDirectory )\n               {\n                   ArchiveEntryUtils.chmod( f, mode );\n               }\n              \n           }else{\n                return;\n           }\n         \n       }\n       catch ( final FileNotFoundException ex )\n       {\n           String path = f.getPath();\n           getLogger().warn( \"Unable to expand to file \" + path );\n       }\n   }\n"
    },
    "VUL4J-43": {
      "prefix": "// Java \npublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n\tthrows IOException\n{\n\tString entryName = entry.getName();\n\tFile outFile = new File(destDir,entryName);\n\t/* BUG: \n\t * if (!entry.isDirectory()) {\n\t * FIXED: \n\t */\n",
      "suffix": "\t\tFile parentFile = outFile.getParentFile();\n\t\tparentFile.mkdirs();\n\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\tIOUtil.writeStream(in, outFile);\n\t\t}\n\t}\n\telse {\n\t\toutFile.mkdirs();\n\t}\n}\n"
    },
    "VUL4J-44": {
      "prefix": "// Java \npublic String encodeCharacter( char[] immune, Character c )\n{\n\tchar charValue = c.charValue();\n\tString cStr = String.valueOf(charValue);\n\t/* BUG: \n\t * if(!UNENCODED_SET.contains(c)){\n\t * FIXED: \n\t */\n",
      "suffix": "\t\tbyte[] bytes = toUtf8Bytes(cStr);\n\t\tStringBuilder sb = new StringBuilder(bytes.length * 3);\n\t\tint i =0;\n\t\twhile(i<bytes.length){\n\t\t\tsb.append('%');\n\t\t\tappendTwoUpperHex(sb, bytes[i]);\n\t\t\ti++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\treturn cStr;\n}\n"
    },
    "VUL4J-46": {
      "prefix": "// Java \n   protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n           XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n           String nameForTextElem)\n   {\n       super(oc);\n       if (xmlOut == null) {\n           xmlOut =  XMLOutputFactory.newInstance();\n       }\n       _xmlGeneratorFeatures = xgFeatures;\n      \n       if (xmlIn == null) {\n           /* BUG: \n            * xmlIn = XMLInputFactory.newInstance();\n            * FIXED: \n            */\n",
      "suffix": "       }\n       _cfgNameForTextElement = nameForTextElem;\n       _xmlParserFeatures = xpFeatures;\n       _initFactories(xmlIn, xmlOut);\n       _xmlOutputFactory = xmlOut;\n       _xmlInputFactory = xmlIn;\n       \n   }\n"
    },
    "VUL4J-47": {
      "prefix": "// Java \nprotected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n        XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n        String nameForTextElem)\n{\n    super(oc);\n    if (xmlOut == null) {\n        xmlOut = XMLOutputFactory.newInstance();\n    }\n    \n    _xmlGeneratorFeatures = xgFeatures;\n    \n    if (xmlIn == null) {\n        xmlIn = XMLInputFactory.newInstance();\n        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n    /* BUG: \n     * }\n     * FIXED: \n     */\n",
      "suffix": "\n    _cfgNameForTextElement = nameForTextElem;\n    _xmlParserFeatures = xpFeatures;\n    _initFactories(xmlIn, xmlOut);\n    _xmlOutputFactory = xmlOut;\n    _xmlInputFactory = xmlIn;\n\n}\n"
    },
    "VUL4J-50": {
      "prefix": "// Java \nprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\tfinal String sessionId = session.getId();\n\tfinal String remoteAddr = session.getRemoteAddr();\n\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\tString sessionIdHtmlEncode=htmlEncodeButNotSpace(sessionId);\n\twrite(sessionIdHtmlEncode);\n\twrite(\"'>\");\n\twrite(sessionIdHtmlEncode);\n\twrite(\"</a>\");\n\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\twrite(nextColumnAlignRight);\n\tString lastAccess = durationFormat.format(session.getLastAccess());\n\tString age = durationFormat.format(session.getAge());\n\tString exprDate = expiryFormat.format(session.getExpirationDate());\n\tString attrCount = integerFormat.format(session.getAttributeCount());\n\tString serializedSize = integerFormat.format(session.getSerializedSize());\n\twrite(lastAccess);\n\twrite(nextColumnAlignRight);\n\twrite(age);\n\twrite(nextColumnAlignRight);\n\twrite(exprDate);\n\twrite(nextColumnAlignRight);\n\twrite(attrCount);\n\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\tfinal String nextColumn = \"</td><td>\";\n\twrite(nextColumnAlignCenter);\n\tString s1 = !session.isSerializable()? \"<span class='severe'>#non#</span>\": \"#oui#\";\n\twrite(s1);\n\twrite(nextColumnAlignRight);\n\twrite(serializedSize);\n\twrite(nextColumn);\n\t/* BUG: \n\t * String s2 = remoteAddr != null? remoteAddr:\"&nbsp;\";\n\t * write(s2);\n\t * FIXED: \n\t */\n",
      "suffix": "\twrite(nextColumnAlignCenter);\n\twriteCountry(session);\n\tfinal String remoteUser = session.getRemoteUser();\n\tif (displayUser) {\n\t\twrite(nextColumn);\n\t\tif (remoteUser != null) {\n\t\t\tString remoteUserhtmlEncode = htmlEncodeButNotSpace(remoteUser);\n\t\t\twriteDirectly(remoteUserhtmlEncode);\n\t\t} else {\n\t\t\twrite(\"&nbsp;\");\t\n\t\t}\n\t}\n\tString sessionIdeEncoded =urlEncode(sessionId);\n\twrite(\"</td><td align='center' class='noPrint'>\");\n\twrite(\"<a href='?part=sessions\");\n\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\twrite(sessionIdeEncoded);\n\tString str_from_js = getStringForJavascript(\"confirm_invalidate_session\");\n\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t+  str_from_js + \"');\\\">\");\n\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\twrite(\"</a>\");\n\twrite(\"</td>\");\n}"
    },
    "VUL4J-53": {
      "prefix": "// Java \nvoid setTo(Calendar c, int i) {\n    /* BUG: \n     * int n = i-offset;\n     * c.set(field, n);\n     * FIXED: \n     */\n",
      "suffix": "}\n"
    },
    "VUL4J-55": {
      "prefix": "// Java \npublic Calendar ceil(Calendar cal) {\n    Calendar twoYearsFuture = (Calendar) cal.clone();\n    twoYearsFuture.add(Calendar.YEAR, 2);\n    OUTER:\n    while (true) {\n        if (cal.compareTo(twoYearsFuture) <= 0) {\n            int i =0;\n            while (i< CalendarField.ADJUST_ORDER.length) {\n                CalendarField f = CalendarField.ADJUST_ORDER[i++];\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   \n\n                CalendarField l=f.lowerField;\n                while (l!=null){\n                    l.clear(cal);\n                    l=l.lowerField;\n                }\n\n                if (next>=0) {\n                    f.setTo(cal,next);\n                    /* BUG: \n                     * if (f.redoAdjustmentIfModified)\n                     * FIXED: \n                     */\n",
      "suffix": "                        continue OUTER; \n                    \n                } else {\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    continue OUTER;    \n                }\n            }\n            return cal; \n            \n        }else{\n            throw new RareOrImpossibleDateException();\n        }\n\n    }\n}\n"
    },
    "VUL4J-57": {
      "prefix": "// Java \n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override\npublic boolean start() throws Exception {\n    String job = step.getJob();\n    Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n    if (item != null) {\n        /* BUG: \n         * if ( !step.getWait() || (item instanceof Job)) {\n         * FIXED: \n         */\n",
      "suffix": "            if(!(item instanceof ParameterizedJobMixIn.ParameterizedJob)){\n                if(!(item instanceof Queue.Task)){\n                    String s;\n                    if(item instanceof Describable){\n                        s =  ((Describable) item).getDescriptor().getDisplayName();\n                    }else{\n                        s =  item.getClass().getName();\n                    }\n                    throw new AbortException(\"The item named \" + job + \" is a \" + s  + \" which is not something that can be built\");\n                }else{\n                    if (step.getParameters() == null || step.getParameters().isEmpty()) {\n                        Queue.Task task = (Queue.Task) item;\n                        String itemEncoded = ModelHyperlinkNote.encodeTo(item);\n                        listener.getLogger().println(\"Scheduling item: \" +itemEncoded );\n                        String taskName = task.getFullDisplayName();\n                        String name  = Messages.BuildTriggerStepExecution_building_(taskName);\n                        LabelAction labelAction = new LabelAction(name);\n                        node.addAction(labelAction);\n                        List<Action> actions = new ArrayList<>();\n                        if (step.getWait()) {\n                            StepContext context = getContext();\n                            boolean isPropagate =  step.isPropagate();\n                            actions.add(new BuildTriggerAction(context, isPropagate ));\n                            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n                        }\n                        Cause.UpstreamCause cause = new Cause.UpstreamCause(invokingRun);\n                        CauseAction causeAction = new CauseAction(cause);\n                        actions.add( causeAction);\n                        Integer quietPeriod = step.getQuietPeriod();\n                        if (quietPeriod == null) {\n                            try {\n                                Class taskClass = task.getClass();\n                                Method getQuietPeriod = taskClass.getMethod(\"getQuietPeriod\");\n                                Class returnType  = getQuietPeriod.getReturnType();\n                                if (returnType.equals(int.class)) {\n                                    quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                                }\n                            } catch (NoSuchMethodException e) {\n                            } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                                LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                            }\n                        }\n                        quietPeriod = quietPeriod == null? Jenkins.getActiveInstance().getQuietPeriod():quietPeriod;\n                        Jenkins activeInstance = Jenkins.getActiveInstance();\n                        ScheduleResult scheduleResult = activeInstance.getQueue().schedule2(task, quietPeriod,actions);\n                        if (scheduleResult.isRefused()) {\n                            throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n                        }\n\n                    }else{\n                        throw new AbortException(\"Item type does not support parameters\");\n                    }\n                }\n            }else{\n                final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n                listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n                node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n                List<Action> actions = new ArrayList<>();\n                if (step.getWait()) {\n                    StepContext context = getContext();\n                    boolean isPropagate =  step.isPropagate();\n                    actions.add(new BuildTriggerAction(context,isPropagate ));\n                    LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n                }\n\n                Cause.UpstreamCause cause = new Cause.UpstreamCause(invokingRun);\n                CauseAction causeAction = new CauseAction(cause);\n                actions.add(causeAction);\n                List<ParameterValue> parameters = step.getParameters();\n                if (parameters != null) {\n                    parameters = completeDefaultParameters(parameters, (Job) project);\n                    actions.add(new ParametersAction(parameters));\n                }\n                Integer quietPeriod = step.getQuietPeriod();\n                if (quietPeriod == null) {\n                    quietPeriod = project.getQuietPeriod();\n                }\n                QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                    @Override\n                    protected Job asJob() {\n                        return (Job) project;\n                    }\n                }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n                if (f == null) {\n                    throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n                }\n            } \n\n            if (!step.getWait()) {\n                getContext().onSuccess(null);\n                return true;\n            } else {\n                return false;\n            }\n\n            \n        }else{\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n            \n    }else{\n        throw new AbortException(\"No item named \" + job + \" found\");\n    }\n\n}\n"
    },
    "VUL4J-59": {
      "prefix": "// Java \n      void read(Tokeniser t, CharacterReader r) {\n           char c = r.consume();\n           if(c== eof){\n               t.eofError(this);\n               /* BUG: \n                * t.transition(Data);\n                * FIXED: \n                */\n",
      "suffix": "               return;\n           }\n           if (c == '\\f' || c ==  '\\n' || c==   ' '|| c== '\\r' || c == '\\t'){\n               return;\n           }\n           if(c =='\\'' ){\n               t.transition(AttributeValue_singleQuoted);\n               return;\n           }\n           if( c==  '>'){\n               t.error(this);\n               t.emitTagPending();\n               t.transition(Data);\n               return;\n           }\n           if(c == nullChar){\n               t.error(this);\n               t.tagPending.appendAttributeValue(replacementChar);\n               t.transition(AttributeValue_unquoted);\n               return;\n           }\n           if(c == '\"'){\n               t.transition(AttributeValue_doubleQuoted);\n               return;\n           }\n           if(c =='&' ){\n               r.unconsume();\n               t.transition(AttributeValue_unquoted);\n               return;\n           }\n           if ( c== '<' || c == '`' || c == '='){\n               t.error(this);\n               t.tagPending.appendAttributeValue(c);\n               t.transition(AttributeValue_unquoted);\n               return;\n           }\n           r.unconsume();\n           t.transition(AttributeValue_unquoted);\n       }"
    },
    "VUL4J-61": {
      "prefix": "// Java \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n",
      "suffix": "           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n"
    },
    "VUL4J-64": {
      "prefix": "// Java \n  final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n      XMLInputFactory factory = XMLInputFactory.newInstance();\n      factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n      factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n      /* BUG: \n       * InputStream in = wrapPrefixRemovingInputStream(inputStream);\n       * FIXED: \n       */\n",
      "suffix": "      return factory.createXMLStreamReader(in);\n  }\n"
    },
    "VUL4J-65": {
      "prefix": "// Java \n   static public File allocateFile(File dir, String name) {\n       int q = name.indexOf('?');\n       name = q > 0? name.substring(0, q):name;\n   \n       int dot = name.indexOf('.');\n       String prefix;\n       String suffix;\n       if(dot >= 0){\n           prefix  =  name.substring(0, dot);\n           suffix = name.substring(dot);\n       }else{\n           prefix = name;\n           suffix = \"\";\n       }\n       \n       File file = new File(dir, name);\n       /* BUG: \n        * for(int index = 2;file.exists();index++){\n        * FIXED: \n        */\n",
      "suffix": "           file = new File(dir, prefix + \"-\" + index + suffix);\n       }\n  \n       File parentFile = file.getParentFile();\n       parentFile.mkdirs();\n       \n       return file;\n   }\n"
    },
    "VUL4J-66": {
      "prefix": "// Java \nprotected static boolean isValid(String str)\n{\n   if (str != null && str.length() != 0){\n      int i =0;\n      while(i < str.length()) {\n         char c = str.charAt(i);\n         i++;\n         /* BUG: \n          * if (c == '/'|| c=='\\\\' || c == '?' || c == ':' || c== '<' || c == '>' || c == ';' || c== '(' || c== ')' || c =='@' || c == ',' || c == '[' || c == ']' || c == '='){\n          * FIXED: \n          */\n",
      "suffix": "            return false;\n         }   \n      }\n      return true;\n   }\n   return false;\n}\n"
    },
    "VUL4J-73": {
      "prefix": "// Java \npublic boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n\t/* BUG: \n\t * String pass2 = mergePasswordAndSalt(rawPass, salt, false);\n\t * String pass1 = encPass + \"\";\n\t * FIXED: \n\t */\n",
      "suffix": "\tpass1 = ignorePasswordCase? pass1.toLowerCase(Locale.ENGLISH): pass1;\n\tpass2 = ignorePasswordCase? pass2.toLowerCase(Locale.ENGLISH): pass2;\n\treturn PasswordEncoderUtils.equals(pass1, pass2);\n}"
    },
    "VUL4J-74": {
      "prefix": "// Java \npublic SecureRandom getObject() throws Exception {\n\tSecureRandom rnd = SecureRandom.getInstance(algorithm);\n\n\t/* BUG: \n\t * if (seed == null) {\n\t * \trnd.nextBytes(new byte[1]);\n\t * }\n\t * else {\n\t * \tInputStream inputStream = seed.getInputStream();\n\t * \trnd.setSeed(FileCopyUtils.copyToByteArray(inputStream));\n\t * }\n\t * FIXED: \n\t */\n",
      "suffix": "\treturn rnd;\n}\n"
    }
  }
}