{
  "config": "INSERTION_CODEX_MULTILINE_COMMENT",
  "data": {
    "Netty-1": {
      "prefix": "// Java \nprivate void cutHeading(AttachableCharSuccession a) {\n    final int range = a.range();\n    int titleBeginning;\n    int titleTerminal;\n    int terminalColon;\n    int contentBeginning;\n    int contentTerminal;\n    titleBeginning = detectNotSpacing(a, 0);\n    for (titleTerminal = titleBeginning; titleTerminal < range; titleTerminal ++) {\n        char z = a.insecureCharAt(titleTerminal);\n        /* BUG: \n         * if (z == ':' || Character.isWhitespace(z)) {\n         * FIXED: \n         */\n",
      "suffix": "            break;\n        }\n    }\n    for (terminalColon = titleTerminal; terminalColon < range; terminalColon ++) {\n        if (a.insecureCharAt(terminalColon) == ':') {\n            terminalColon ++;\n            break;\n        }\n    }\n    title = a.partOfStringInsecure(titleBeginning, titleTerminal);\n    contentBeginning = detectNotSpacing(a, terminalColon);\n    if (contentBeginning == range) {\n        content = BLANK_CONTENT;\n    } else {\n        contentTerminal = detectTerminalOfString(a);\n        content = a.partOfStringInsecure(contentBeginning, contentTerminal);\n    }\n}"
    },
    "Netty-2": {
      "prefix": "// Java \nprivate void cutHeading(AttachableCharSuccession a) {\n    final int range = a.range();\n    int titleBeginning;\n    int titleTerminal;\n    int terminalColon;\n    int contentBeginning;\n    int contentTerminal;\n    titleBeginning = detectNotSpacing(a, 0);\n    for (titleTerminal = titleBeginning; titleTerminal < range; titleTerminal ++) {\n        char z = a.insecureCharAt(titleTerminal);\n        if (z == ':' ||\n                (!beDecryptionDemand() && Character.isWhitespace(z))) {\n            break;\n        }\n    }\n    /* BUG: \n     * for (terminalColon = titleTerminal; terminalColon < range; terminalColon ++) {\n     * FIXED: \n     */\n",
      "suffix": "        if (a.insecureCharAt(terminalColon) == ':') {\n            terminalColon ++;\n            break;\n        }\n    }\n    title = a.partOfStringInsecure(titleBeginning, titleTerminal);\n    contentBeginning = detectNotSpacing(a, terminalColon);\n    if (contentBeginning == range) {\n        content = BLANK_CONTENT;\n    } else {\n        contentTerminal = detectTerminalOfString(a);\n        content = a.partOfStringInsecure(contentBeginning, contentTerminal);\n    }\n}"
    },
    "Jenkins-1": {
      "prefix": "// Java \n@Exported(inline=true)\npublic Map<String,Object> acquireProctorInformation() {\n    Map<String,Object> z = new HashMap<String, Object>();\n    /* BUG: \n     * for (VertexProctor proctor : VertexProctor.acquireWhole())\n     *     z.put(proctor.getClass().getName(),proctor.information(this));\n     * FIXED: \n     */\n",
      "suffix": "    return z;\n}"
    },
    "Jenkins-2": {
      "prefix": "// Java \n@Exported(name=\"jobs\")\npublic List<PeakDegreeElement> acquireElements() {\n    /* BUG: \n     * if (mandateScheme instanceof MandateScheme.Unguarded ||\n     *     mandateScheme instanceof CompleteDominanceWhenLoggedInMandateScheme) {\n     *     return new ArrayList(elements.values());\n     * }\n     * FIXED: \n     */\n",
      "suffix": "\n    List<PeakDegreeElement> visibleElements = new ArrayList<PeakDegreeElement>();\n    for (PeakDegreeElement element : elements.values()) {\n        if (element.withAuthority(Item.RETRIEVE))\n            visibleElements.add(element);\n    }\n    return visibleElements;\n}"
    },
    "Jenkins-3": {
      "prefix": "// Java \n@Override\npublic LookupIndexCreator constructLookupIndex() {\n    return super.constructLookupIndex()\n        .attach(\"configure\", \"config\",\"configure\")\n        .attach(\"manage\")\n        .attach(\"log\")\n        .attach(new AggregationLookupIndex<PeakDegreeElement>() {\n            protected LookupElement acquire(String clue) { return acquireElementUsingWholeName(clue, PeakDegreeElement.class); }\n            protected Collection<PeakDegreeElement> whole() { return acquireEveryElement(PeakDegreeElement.class); }\n        })\n        .attach(acquireMainUIComponent().constructLookupIndex())\n        .attach(new AggregationLookupIndex() {\n            protected ComputingMachine acquire(String clue) { return acquireComputingMachine(clue); }\n            protected Collection<ComputingMachine> whole() { return computingMachines.values(); }\n        })\n        .attach(new AggregationLookupIndex() {\n            protected Client acquire(String clue) { return Client.acquire(clue,false); }\n            protected Collection<Client> whole() { return Client.acquireWhole(); }\n        })\n        .attach(new AggregationLookupIndex() {\n            protected UIComponent acquire(String clue) { return acquireUIComponent(clue); }\n            /* BUG: \n             * protected Collection<UIComponent> whole() { return uiComponents; }\n             * FIXED: \n             */\n",
      "suffix": "        });\n}"
    },
    "Jinjava-1": {
      "prefix": "// Java \nprivate static final Set<String> CONFINED_ROUTINES = ImmutableSet.<String> builder()\n    .add(\"clone\")\n    .add(\"hashCode\")\n    /* BUG: \n     * .add(\"notify\")\n     * FIXED: \n     */\n",
      "suffix": "    .add(\"notifyAll\")\n    .add(\"wait\")\n    .build();"
    },
    "Halo-1": {
      "prefix": "// Java \npublic static void examinePathManipulation(@NonNull Path basePath, @NonNull Path examinePath) {\n    Assert.notNull(basePath, \"Parent path must not be null\");\n    Assert.notNull(examinePath, \"Path to check must not be null\");\n    /* BUG: \n     * if (examinePath.startsWith(basePath.normalize())) {\n     * FIXED: \n     */\n",
      "suffix": "        return;\n    }\n    throw new ProhibitedException(\"You do not have permission to access \" + examinePath).specifyErrorInformation(examinePath);\n}"
    },
    "Retrofit-1": {
      "prefix": "// Java \nJaxbReplyTransformer(JAXBContext setting, Class<T> category) {\n  this.setting = setting;\n  /* BUG: \n   * this.category = category;\n   * FIXED: \n   */\n",
      "suffix": "}"
    },
    "Quartz-1": {
      "prefix": "// Java \nprotected void loadArchiveAnalyzer() throws ParserConfigurationException  {\n    DocumentBuilderFactory archiveCreatorManufactory = DocumentBuilderFactory.newInstance();\n    archiveCreatorManufactory.setNamespaceAware(true);\n    archiveCreatorManufactory.setValidating(true);\n    archiveCreatorManufactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n    archiveCreatorManufactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", solveSchemeOrigin());\n    /* BUG: \n     * archiveCreator = archiveCreatorManufactory.newDocumentBuilder();\n     * FIXED: \n     */\n",
      "suffix": "    \n    archiveCreator.setErrorHandler(this);\n    NamespaceContext nsCircumstance = new NamespaceContext()\n    {\n      public String acquireTitilescopeURI(String beginningOfString)\n      {\n          if (beginningOfString == null)\n              throw new IllegalArgumentException(\"Null prefix\");\n          if (XMLConstants.XML_NS_PREFIX.equals(beginningOfString))\n              return XMLConstants.XML_NS_URI;\n          if (XMLConstants.XMLNS_ATTRIBUTE.equals(beginningOfString))\n              return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n          if (\"q\".equals(beginningOfString))\n              return PROJECT_TS;\n          return XMLConstants.NULL_NS_URI;\n      }\n      public Iterator<?> acquireBeginningsOfStrings(String titlescopeURI)\n      {\n          throw new UnsupportedOperationException();\n      }\n      public String acquireBeginningOfString(String titlescopeURI)\n      {\n          throw new UnsupportedOperationException();\n      }\n    }; \n    path = XPathFactory.newInstance().newXPath();\n    path.setNamespaceContext(nsCircumstance);\n}"
    },
    "Flow-1": {
      "prefix": "// Java \npublic boolean workForDevMannerDemand(HttpServletRequest query,\n        HttpServletResponse reply) throws IOException {\n    if (whetherDevelopComputerUnsuccessfulBegin.get() || !developComputerBeginFuturity.isDone()) {\n        return false;\n    }\n    String queryFileName = query.getPathInfo();\n    /* BUG: \n     * if (OperatorAssistant.whetherPathInsecure(queryFileName)) {\n     *     getLogger().info(OperatorAssistant.INSECURE_PATH_ERROR_INFORMATION_FORM,\n     * FIXED: \n     */\n",
      "suffix": "                queryFileName);\n        reply.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        return true;\n    }\n    if(APP_SUBJECT_FORM.matcher(queryFileName).find()) {\n        queryFileName = \"/VAADIN/static\" + queryFileName;\n    }\n    HttpURLConnection connexion = arrangeLink(queryFileName,\n            query.getMethod());\n    Enumeration<String> headingTiles = query.getHeaderNames();\n    while (headingTiles.hasMoreElements()) {\n        String heading = headingTiles.nextElement();\n        connexion.setRequestProperty(heading,\n                \"Connect\".equals(heading) ? \"close\"\n                        : query.getHeader(heading));\n    }\n    getLogger().debug(\"Requesting resource to webpack {}\",\n            connexion.getURL());\n    int replyCode = connexion.getResponseCode();\n    if (replyCode == HTTP_NOT_FOUND) {\n        getLogger().debug(\"Resource not served by webpack {}\",\n                queryFileName);\n        return false;\n    }\n    getLogger().debug(\"Served resource by webpack: {} {}\", replyCode,\n            queryFileName);\n    connexion.getHeaderFields().forEach((heading, contents) -> {\n        if (heading != null) {\n            reply.addHeader(heading, contents.get(0));\n        }\n    });\n    if (replyCode == HTTP_OK) {\n        composeDataSequence(reply.getOutputStream(),\n                connexion.getInputStream());\n    } else if (replyCode < 400) {\n        reply.setStatus(replyCode);\n    } else {\n        reply.sendError(replyCode);\n    }\n    reply.getOutputStream().close();\n    return true;\n}"
    },
    "Flow-2": {
      "prefix": "// Java \n@Override\npublic int putMistakeAttribute(PriorToComeInCase occurrence,\n        ErrorAttribute<UndiscoveredException> attribute) {\n    String way = occurrence.acquirePlacement().acquirePath();\n    String extraInformation = \"\";\n    if (attribute.withPersonalizedContent()) {\n        extraInformation = \"Reason: \" + attribute.acquirePersonalizedContent();\n    }\n    way = Jsoup.clean(way, Whitelist.none());\n    extraInformation = Jsoup.clean(extraInformation, Whitelist.none());\n    boolean productManner = occurrence.acquireUI().acquireSession().acquireArrangement()\n            .beProductManner();\n    String templet = acquireMistakeHypertextMarkupLanguage(productManner);\n    /* BUG: \n     * templet = templet.replace(\"{{path}}\", way);\n     * templet = templet.replace(\"{{additionalInfo}}\", extraInformation);\n     * if (templet.contains(\"{{routes}}\")) {\n     *     templet = templet.replace(\"{{routes}}\", acquireWays(occurrence));\n     * }\n     * FIXED: \n     */\n",
      "suffix": "\n    acquireComponent().attachMember(new HypertextMarkupLanguage(templet).acquireComponent());\n    return HttpServletResponse.SC_NOT_FOUND;\n}"
    },
    "BC-Java-1": {
      "prefix": "// Java \nprivate LargeWholeNumber[] derDecrypt(\n    byte[]  encryption)\n    throws IOException\n{\n    ASN1Succession S = (ASN1Succession)ASN1Basic.outOfByteArray(encryption);\n    /* BUG: \n     * return new LargeWholeNumber[]{\n     * FIXED: \n     */\n",
      "suffix": "        ((ASN1WholeNumber)S.acquireItemAt(0)).acquireContent(),\n        ((ASN1WholeNumber)S.acquireItemAt(1)).acquireContent()\n    };\n}"
    },
    "Json-sanitizer-1": {
      "prefix": "// Java \nprivate void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter != '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n      /* BUG: \n       * case '/':\n       *   if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n       *       && 's' == (JSONlike.charAt(h + 1) | 32)\n       *       && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n       *     embed(h, '\\\\');\n       *   }\n       *   break;\n       * FIXED: \n       */\n",
      "suffix": "      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n"
    },
    "Ratpack-1": {
      "prefix": "// Java \nprivate void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption != null);\n  QueryContent queryContent = withContent ? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent != null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  /* BUG: \n   * HttpHeaders heading = new DefaultHttpHeaders(false);\n   * FIXED: \n   */\n",
      "suffix": "  ChangeableHeadings replyHeading = new NetworkLibraryHeadingSupportedChangeableHeadings(heading);\n  AtomicBoolean conveyed = new AtomicBoolean(false);\n  PrimaryReplySender replySender = new PrimaryReplySender(conveyed, channel, time, httpQuery, query, heading, queryContent);\n  context.channel().attr(PrimaryReplySender.ATTRIBUTE_KEY).set(replySender);\n  Operation<Operation<Object>> registerManager = matter -> {\n    conveyed.set(true);\n    context.channel().attr(channelReceiverPropertyKey).set(matter);\n  };\n  PrimaryCircumstance.QueryConstants queryConstants = new PrimaryCircumstance.QueryConstants(\n    appConstants,\n    query,\n    channel,\n    replySender,\n    registerManager\n  );\n  Reply reply = new PrimaryReply(replyHeading, context.alloc(), replySender);\n  queryConstants.reply = reply;\n  PrimaryCircumstance.begin(channel.eventLoop(), queryConstants, hostRepository, managers, executing -> {\n    if (!conveyed.get()) {\n      Manager stoppingPointManager = queryConstants.manager;\n      StringBuilder description = new StringBuilder();\n      description\n        .append(\"No response sent for \")\n        .append(query.acquireFunction().acquireTitle())\n        .append(\" request to \")\n        .append(query.acquireUri());\n      if (stoppingPointManager != null) {\n        description.append(\" (last handler: \");\n        if (stoppingPointManager instanceof RecountingManager) {\n          ((RecountingManager) stoppingPointManager).depictTo(description);\n        } else {\n          RecountingManagers.depictTo(stoppingPointManager, description);\n        }\n        description.append(\")\");\n      }\n      String news = description.toString();\n      LOGGER.warn(news);\n      reply.acquireHeading().empty();\n      ByteBuf content;\n      if (evolution) {\n        CharBuffer charBuffer = CharBuffer.wrap(news);\n        content = ByteBufUtil.encodeString(context.alloc(), charBuffer, CharsetUtil.UTF_8);\n        reply.messageKind(HypertextTransferProtocolHeadingConstants.PLAIN_TEXT_UTF8);\n      } else {\n        content = Unpooled.EMPTY_BUFFER;\n      }\n      reply.acquireHeading().set(HypertextTransferProtocolHeadingConstants.MESSAGE_SIZE, content.readableBytes());\n      replySender.convey(HttpResponseStatus.INTERNAL_SERVER_ERROR, content);\n    }\n  });\n}"
    },
    "Pulsar-1": {
      "prefix": "// Java \nprotected void innerAcquireNewsThroughNumber(AsyncResponse asyncReply, long recordsNumber, long itemNumber,\n                                          boolean reliable) {\n    try {\n        confirmSubjectPossession(subjectTitle, reliable);\n        confirmSubjectAction(subjectTitle, SubjectAction.PEEK_MESSAGES);\n        if (subjectTitle.whetherUniversal()) {\n            confirmUniversalTitleScopePossession(titleScopeTitle);\n        }\n        TenaciousSubject subject = (TenaciousSubject) acquireSubjectMention(subjectTitle);\n        AdministeredRecordsImpl records = (AdministeredRecordsImpl) subject.acquireAdministeredRecords();\n        /* BUG: \n         * records.asyncRetrieveItem(new PlaceImpl(recordsNumber, itemNumber), new AsyncCallbacks.ReadEntryCallback() {\n         * FIXED: \n         */\n",
      "suffix": "            @Override\n            public void retrieveItemUnsuccess(AdministeredRecordsException exception, Object obj) {\n                asyncReply.resume(new RestException(exception));\n            }\n            @Override\n            public void retrieveItemFinish(Item item, Object obj) {\n                try {\n                    asyncReply.resume(produceReplyWithItem(item));\n                } catch (IOException exception) {\n                    asyncReply.resume(new RestException(exception));\n                } finally {\n                    if (item != null) {\n                        item.free();\n                    }\n                }\n            }\n        }, null);\n    } catch (NullPointerException nullPointerException) {\n        asyncReply.resume(new RestException(Status.NOT_FOUND, \"Message not found\"));\n    } catch (Exception exception) {\n        log.error(\"[{}] Failed to get message with ledgerId {} entryId {} from {}\",\n                customerAppNumber(), recordsNumber, itemNumber, subjectTitle, exception);\n        asyncReply.resume(new RestException(exception));\n    }\n}"
    },
    "VUL4J-1": {
      "prefix": "// Java \n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic <T> T inverseConvert(BasicAnalyzerJson analyzer, Type category, Object attributeTitile) {\n    final JsonTokenizer tokenizer = analyzer.tokenizer;\n    if (tokenizer.token() == JSONToken.NULL) {\n        tokenizer.followingToken(JSONToken.COMMA);\n        return null;\n    }\n    if (tokenizer.token() == JSONToken.LITERAL_STR) {\n        byte[] bytes = tokenizer.contentsOfBytes();\n        tokenizer.followingToken(JSONToken.COMMA);\n        return (T) bytes;\n    }\n    Class constituentTemplate;\n    Type constituentCategory;\n    if (category instanceof GenericArrayType) {\n        GenericArrayType clazz = (GenericArrayType) category;\n        constituentCategory = clazz.getGenericComponentType();\n        if (constituentCategory instanceof TypeVariable) {\n            TypeVariable categoryVariable = (TypeVariable) constituentCategory;\n            Type categoryOfObject = analyzer.obtainContext().category;\n            if (categoryOfObject instanceof ParameterizedType) {\n                ParameterizedType parameterizedCategoryOfObject = (ParameterizedType) categoryOfObject;\n                Type originalCategoryOfObject = parameterizedCategoryOfObject.getRawType();\n                Type realCategory = null;\n                if (originalCategoryOfObject instanceof Class) {\n                    TypeVariable[] objectCategoryParameters = ((Class) originalCategoryOfObject).getTypeParameters();\n                    for (int x = 0; x < objectCategoryParameters.length; ++x) {\n                        if (objectCategoryParameters[x].getName().equals(categoryVariable.getName())) {\n                            realCategory = parameterizedCategoryOfObject.getActualTypeArguments()[x];\n                        }\n                    }\n                }\n                if (realCategory instanceof Class) {\n                    constituentTemplate = (Class) realCategory;\n                } else {\n                    constituentTemplate = Object.class;\n                }\n            } else {\n                constituentTemplate = CategoryTools.acquireClass(categoryVariable.getBounds()[0]);\n            }\n        } else {\n            constituentTemplate = CategoryTools.acquireClass(constituentCategory);\n        }\n    } else {\n        Class clazz = (Class) category;\n        constituentCategory = constituentTemplate = clazz.acquireCategoryOfComponent();\n    }\n    JsonBatch batch = new JsonBatch();\n    /* BUG: \n     * analyzer.analyzeBatch(constituentTemplate, batch, attributeTitile);\n     * FIXED: \n     */\n",
      "suffix": "\n    return (T) transformObjectBatch(analyzer, constituentTemplate, batch);\n}"
    },
    "VUL4J-3": {
      "prefix": "// Java \n@Converter\npublic SAXSource transformDataSequenceToSAXSource(StreamSource dataProvider, Interchange interchange) throws SAXException {\n    InputSource inDataProvider;\n    if (dataProvider.getReader() != null) {\n        inDataProvider = new InputSource(dataProvider.getReader());\n    } else {\n        inDataProvider = new InputSource(dataProvider.getInputStream());\n    }\n    inDataProvider.setSystemId(dataProvider.getSystemId());\n    inDataProvider.setPublicId(dataProvider.getPublicId());\n    XMLReader subscriber = null;\n    SAXParserFactory sproducer = null;\n    try {\n        if (interchange != null) {\n            sproducer = interchange.acquireAttribute(Interchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n        }\n        if (sproducer == null) {\n            sproducer = SAXParserFactory.newInstance();\n            try {\n                sproducer.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            } catch (Exception x) {\n                LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", x});\n            }\n        /* BUG: \n         * }\n         * FIXED: \n         */\n",
      "suffix": "        sproducer.setNamespaceAware(true);\n        SAXParser analyzer = sproducer.newSAXParser();\n        subscriber = analyzer.getXMLReader();\n    } catch (Exception p) {\n        LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", p);\n    }\n    return new SAXSource(subscriber, inDataProvider);\n}"
    },
    "VUL4J-4": {
      "prefix": "// Java \nprotected Object doAcquireArchive(Interchange interchange, Object content) throws Exception {\n    if (content == null) {\n        return null;\n    }\n    Object reply = null;\n    Class<?> category = acquireArchiveCategory();\n    Exception reason = null;\n    if (category != null) {\n        try {\n            reply = interchange.acquireCircumstance().acquireCategoryTransformer().transformTo(category, interchange, content);\n        } catch (Exception x) {\n            reason = x;\n        }\n    }\n    \n    /* BUG: \n     * if (reply == null) {\n     *     if (content instanceof WrappedFile) {\n     *         InputStream inputStream = interchange.acquireCircumstance().acquireCategoryTransformer().transformTo(InputStream.class, interchange, content);\n     *         reply = new InputSource(inputStream);\n     *     } else if (content instanceof BeanExecution) {\n     *         BeanExecution be = interchange.acquireCircumstance().acquireCategoryTransformer().transformTo(BeanExecution.class, interchange, content);\n     *         if (be.acquireParameters() != null && be.acquireParameters().length == 1 && be.acquireParameters()[0] == null) {\n     *             reply = null;\n     *         }\n     *     } else if (content instanceof String) {\n     *         reply = new InputSource(new StringReader((String) content));\n     *     }\n     * }\n     * FIXED: \n     */\n",
      "suffix": "    if (category == null && reply == null) {\n        reply = content;\n    } else if (reply == null) {\n        if (reason != null) {\n            throw reason;\n        } else {\n            throw new NoCategoryTransformationApplicableException(content, category);\n        }\n    }\n    return reply;\n}"
    },
    "VUL4J-5": {
      "prefix": "// Java \nprivate void enlarge(DocumentItemProvider provider, ItemNoter noter, File objectiveFolder)\n    throws IOException {\n    /* BUG: \n     * String objectiveDirectoryPath = objectiveFolder.getCanonicalPath();\n     * FIXED: \n     */\n",
      "suffix": "    DocumentItem followingItem = provider.acquireFollowingLegibleItem();\n    while (followingItem != null) {\n        File f = new File(objectiveFolder, followingItem.acquireTitle());\n        if (!f.getCanonicalPath().startsWith(objectiveDirectoryPath)) {\n            throw new IOException(\"expanding \" + followingItem.acquireTitle()\n                + \" would create file outside of \" + objectiveFolder);\n        }\n        if (followingItem.whetherFolder()) {\n            if (!f.isDirectory() && !f.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + f);\n            }\n        } else {\n            File upperFolder = f.getParentFile();\n            if (!upperFolder.isDirectory() && !upperFolder.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + upperFolder);\n            }\n            try (OutputStream u = Files.newOutputStream(f.toPath())) {\n                noter.noteDownItemInformationTo(followingItem, u);\n            }\n        }\n        followingItem = provider.acquireFollowingLegibleItem();\n    }\n}"
    },
    "VUL4J-6": {
      "prefix": "// Java \npublic void analyzeCentralDirectoryScheme(final byte[] information, final int beginning, final int duration) {\n    this.formatting = ZipTwoByteInteger.acquireContent(information, beginning);\n    this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2));\n    this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4);\n    this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6);\n    this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8);\n    if (rcount > 0) {\n        this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12));\n        this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14);\n        /* BUG: \n         * for (int iodine = 0; iodine < this.rcount; iodine++) {\n         * FIXED: \n         */\n",
      "suffix": "            for (int joule = 0; joule < this.hashishSizing; joule++) {\n            }\n        }\n    }\n}"
    },
    "VUL4J-7": {
      "prefix": "// Java \nprivate int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException {\n    if (present.withInformationForm) {\n        if (finalSavedItem == null) {\n            retrieveSavedItem();\n        }\n        return finalSavedItem.read(byteArrary, distance, range);\n    }\n    final long size = present.item.acquireSize();\n    if (present.byteRetrieved >= size) {\n        return -1;\n    }\n    if (memory.position() >= memory.limit()) {\n        memory.position(0);\n        final int x = input.read(memory.array());\n        if (x == -1) {\n            /* BUG: \n             * return -1;\n             * FIXED: \n             */\n",
      "suffix": "        }\n        memory.limit(x);\n        calculate(x);\n        present.byteRetrievedFromDataSequence += x;\n    }\n    int toRetrieve = Math.min(memory.remaining(), range);\n    if ((size - present.byteRetrieved) < toRetrieve) {\n        toRetrieve = (int) (size - present.byteRetrieved);\n    }\n    memory.get(byteArrary, distance, toRetrieve);\n    present.byteRetrieved += toRetrieve;\n    return toRetrieve;\n}"
    },
    "VUL4J-8": {
      "prefix": "// Java \n@Override\npublic ByteBuffer encode(final String tile) {\n    final CharsetEncoder charEncoder = newEncoder();\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    CharBuffer cb_temp = null;\n    ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining()));\n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n        if (outcome.isUnmappable() || outcome.isMalformed()) {\n            int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length());\n            if (roomForSubstitute > result.remaining()) {\n                int charAmount = 0;\n                for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) {\n                    charAmount += !charEncoder.ableToEncode(charBuffer.get(j)) ? 6 : 1;\n                }\n                int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount);\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining());\n            }\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(6);\n            }\n            for (int j = 0; j < outcome.length(); ++j) {\n                result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result);\n            }\n        } else if (outcome.isOverflow()) {\n            int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining());\n            /* BUG: \n             * result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase);\n             * FIXED: \n             */\n",
      "suffix": "        }\n    }\n    charEncoder.encode(charBuffer, result, true);\n    result.limit(result.position());\n    result.rewind();\n    return result;\n}"
    },
    "VUL4J-10": {
      "prefix": "// Java \nprivate void readItem(ObjectInputStream inputStream)\n        throws IOException, ClassNotFoundException {\n    inputStream.defaultReadObject();\n    /* BUG: \n     * OutputStream production = acquireOutDataSequence();\n     * FIXED: \n     */\n",
      "suffix": "    if (savedData != null) {\n        production.write(savedData);\n    } else {\n        FileInputStream in = new FileInputStream(serializationFile);\n        IOUtils.copy(in, production);\n        serializationFile.delete();\n        serializationFile = null;\n    }\n    production.close();\n    savedData = null;\n}"
    },
    "VUL4J-12": {
      "prefix": "// Java \nprivate int enlarge(int s, final int z) {\n    int h = (1 << (z - 1));\n    /* BUG: \n     * while (s < h) {\n     * FIXED: \n     */\n",
      "suffix": "        h = (-1 << z) + 1;\n        s += h;\n    }\n    return s;\n}"
    },
    "VUL4J-18": {
      "prefix": "// Java \npublic String acquireSendOnPage( HttpServletRequest r )\n{\n    /* BUG: \n     * return r.getPathInfo();\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "VUL4J-19": {
      "prefix": "// Java \n@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1 ? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else if( beExploiterWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                       lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                       lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = new UseConsent(lexiconConsent);\n        /* BUG: \n         * adjustPresentUseConsent(presentUseConsent);\n         * FIXED: \n         */\n",
      "suffix": "        \n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                watchword.getBytes(watchwordCharSet),\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    else\n    {\n        throw new IneffectiveWatchwordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        formalizePerm(cipher, lexiconConsent, cipherDescriptiveData);\n    }\n    if (cipher.acquireEdition() == 4 || cipher.acquireEdition() == 5)\n    {\n        PalladiumFiltrateLexicon standardCryptPurifyLexicon = cipher.acquireStandardCryptPurifyLexicon();\n        if (standardCryptPurifyLexicon != null)\n        {\n            COSTitle cryptPurifyApproach = standardCryptPurifyLexicon.acquireCryptPurifyApproach();\n            adjustAES(COSTitle.AESV2.equals(cryptPurifyApproach) || \n                   COSTitle.AESV3.equals(cryptPurifyApproach));\n        }\n    }\n}"
    },
    "VUL4J-20": {
      "prefix": "// Java \npublic float[] transformToFloatArray()\n{\n    float[] result = new float[length()];\n    for (int j = 0; j < length(); j++)\n    {\n        /* BUG: \n         * result[j] = ((COSNumeral)acquireItem( j )).floatContent();\n         * FIXED: \n         */\n",
      "suffix": "    }\n    return result;\n}"
    },
    "VUL4J-22": {
      "prefix": "// Java \npublic static String getContextPath(HttpServletRequest r) {\n    String circumstancePath = (String) r.getAttribute(ADD_CIRCUMSTANCE_PATH_PROPERTY);\n    if (circumstancePath == null) {\n        circumstancePath = r.getContextPath();\n    }\n    /* BUG: \n     * if (\"/\".equals(circumstancePath)) {\n     *     \n     *     circumstancePath = \"\";\n     * }\n     * return decryptRequestContent(r, circumstancePath);\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "VUL4J-23": {
      "prefix": "// Java \n@Override\npublic String JavaScriptStringEncoding(String dataProvider) {\n    /* BUG: \n     * return dataProvider == null ? null : Encode.forJavaScriptSource(dataProvider);\n     * FIXED: \n     */\n",
      "suffix": "}\n"
    },
    "VUL4J-25": {
      "prefix": "// Java \n@Override\n@Nonnull\npublic String acquireReasonableHref(final String resourseAddress) {\n    if (StringUtils.isNotEmpty(resourseAddress)) {\n /* BUG: \n  *        try {\n  *            String resourseAddressUnescaped = URLDecoder.decode(resourseAddress, StandardCharsets.UTF_8.name());\n  *            resourseAddressUnescaped = StringEscapeUtils.unescapeXml(resourseAddressUnescaped);\n  *            String convertedResourseAddress = resourseAddressUnescaped.replaceAll(\"\\\"\", \"%22\")\n  *                    .replaceAll(\"'\", \"%27\")\n  *                    .replaceAll(\">\", \"%3E\")\n  *                    .replaceAll(\"<\", \"%3C\")\n  *                    .replaceAll(\"`\", \"%60\")\n  *                    .replaceAll(\" \", \"%20\");\n  *            int index = convertedResourseAddress.indexOf('?');\n  *            if (index > 0) {\n  *                convertedResourseAddress = convertedResourseAddress.substring(0, index) + convertedResourseAddress.substring(index).replaceAll(\":\", \"%3A\");\n  *            }\n\n *   *            convertedResourseAddress = mutilateTitleScope(convertedResourseAddress);\n  *            if (xssStrainer.whetherReasonableHref(convertedResourseAddress)) {\n  *                return convertedResourseAddress;\n  *            }\n  *        } catch (UnsupportedEncodingException x) {\n  *            LOGGER.error(\"Unable to decode url: {}.\", resourseAddress);\n  *        }\n  * FIXED: \n  */\n",
      "suffix": "    }\n    return \"\";\n}"
    },
    "VUL4J-26": {
      "prefix": "// Java \npublic String acquireUrlRegularExpression() {\n    if (StringUtils.isNotEmpty(urlRegularExpressionExpr)) {\n        return (String) analyze(urlRegularExpressionExpr, String.class);\n    } else if (StringUtils.isNotEmpty(urlRegularExpression)) {\n        return urlRegularExpression;\n    } else {\n        return \"^(https?|ftp):\\\\/\\\\/\" +\n                \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                \"@)?(#?\" +\n                \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                \")(:\\\\d+)?\" +\n                /* BUG: \n                 * \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                 * FIXED: \n                 */\n",
      "suffix": "                \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                \"?)?)?\" +\n                \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                \"$\";\n    }\n}"
    },
    "VUL4J-30": {
      "prefix": "// Java \npublic void approve(Object item) throws ValidationException {\n    String attributeTitle = acquireAttributeTitle();\n    Object content = this.acquireAttributeContent(attributeTitle, item);\n    if (content == null || content.toString().length() == 0) {\n        return;\n    }\n    /* BUG: \n     * if (!(content.getClass().equals(String.class)) || !Pattern.compile(acquireUrlRegularExpression(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(content)).matches()) {\n     * FIXED: \n     */\n",
      "suffix": "        attachAttributeError(attributeTitle, item);\n    }\n}"
    },
    "VUL4J-39": {
      "prefix": "// Java \n@Override\npublic String toString() {\n    StringBuilder s = new StringBuilder();\n    if (source != null) {\n        s.append(\"remoteAddress=\").append(source);\n    }\n    if (customerIdentification != null) {\n        if (s.length() > 0) {\n            s.append(\", \");\n        }\n        s.append(\"clientId=\").append(customerIdentification);\n    }\n    /* BUG: \n     * if (sessionIdentification != null) {\n     *     if (s.length() > 0) {\n     *         s.append(\", \");\n     *     }\n     *     s.append(\"sessionId=\").append(sessionIdentification);\n     * }\n     * FIXED: \n     */\n",
      "suffix": "    return s.toString();\n}"
    },
    "VUL4J-40": {
      "prefix": "// Java \npublic boolean whetherPermitted(HttpServletRequest request) throws IOException {\n    String requestContent = IOUtils.toString(request.getReader());\n    Customer CustomerOfRequest = JsonTools.retrieveContent(requestContent, Customer.class);\n    String identification = URLTools.derivePathObjectFromURL(CUSTOMER_IDENTIFICATION_PATH_ARGUMENT_INDEX, URLTools.acquireRequestPath(request));\n    String areaIdentification = IndividualityAreaPossessor.acquire().acquireIdentification();\n    Customer CustomerOfDatabase;\n    try {\n        CustomerOfDatabase = CustomerManagement.recover(identification, areaIdentification);\n    } catch (DataSourceUnfoundException x) {\n        return true;\n    }\n    if (!CustomerOfDatabase.acquireMainEmail().equals(CustomerOfRequest.acquireMainEmail())) {\n        return false;\n    }\n    /* BUG: \n     * if (!CustomerOfDatabase.acquireCustomerTitle().equals(CustomerOfRequest.acquireCustomerTitle())) {\n     * FIXED: \n     */\n",
      "suffix": "        return false;\n    }\n    if (CustomerOfDatabase.whetherAuthenticated() != CustomerOfRequest.whetherAuthenticated()) {\n        return false;\n    }\n    if (CustomerOfDatabase.whetherInAction() != (CustomerOfRequest.whetherInAction())) {\n        return false;\n    }\n    if (!CustomerOfDatabase.acquireSource().equals(CustomerOfRequest.acquireSource())) {\n        return false;\n    }\n    return true;\n}"
    },
    "VUL4J-41": {
      "prefix": "// Java \nprotected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence,\n                            final String itemTitle, final Date itemTime, final boolean whetherFolder,\n                            final Integer setting, String symbolicLinkTargetLocation )\n    throws IOException, DocumentorException\n{\n    final File targetFile = FileUtils.resolveFile( folder, itemTitle );\n    /* BUG: \n     * try\n     * FIXED: \n     */\n",
      "suffix": "    {\n        if ( !whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) )\n        {\n            return;\n        }\n        final File parentFile = targetFile.getParentFile();\n        if ( parentFile != null )\n        {\n            parentFile.mkdirs();\n        }\n        if ( !StringUtils.isEmpty( symbolicLinkTargetLocation ) )\n        {\n            SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) );\n        }\n        else if ( whetherFolder )\n        {\n            targetFile.mkdirs();\n        }\n        else\n        {\n            OutputStream output = null;\n            try\n            {\n                output = new FileOutputStream( targetFile );\n                IOUtil.copy( compressedInDataSequence, output );\n                output.close();\n                output = null;\n            }\n            finally\n            {\n                IOUtil.close( output );\n            }\n        }\n        targetFile.setLastModified( itemTime.getTime() );\n        if ( !whetherDisregardConsent() && setting != null && !whetherFolder )\n        {\n            DocumentItemUtility.changeMode( targetFile, setting );\n        }\n    }\n    catch ( final FileNotFoundException e )\n    {\n        acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() );\n    }\n}"
    },
    "VUL4J-43": {
      "prefix": "// Java \npublic static void saveItem(ZipFile compressedFile, ZipEntry item, File targetFolder)\n\tthrows IOException\n{\n\tFile outputFile = new File(targetFolder, item.getName());\n\t/* BUG: \n\t * if (item.isDirectory()) {\n\t * FIXED: \n\t */\n",
      "suffix": "\t\toutputFile.mkdirs();\n\t}\n\telse {\n\t\toutputFile.getParentFile().mkdirs();\n\t\ttry (InputStream input = compressedFile.getInputStream(item)) {\n\t\t\tInputOutputUtility.saveDataSequence(input, outputFile);\n\t\t}\n\t}\n}"
    },
    "VUL4J-44": {
      "prefix": "// Java \npublic String convertChar( char[] exempt, Character a )\n{\n\tString charString = String.valueOf(a.charValue());\n\tbyte[] byteArray;\n\tStringBuilder x;\n\t/* BUG: \n\t * if(NOT_ENCODE_COLLECTION.contains(a))\n\t * FIXED: \n\t */\n",
      "suffix": "\t\treturn charString;\n\tbyteArray = convertToUtf8Bytes(charString);\n\tx = new StringBuilder(byteArray.length * 3);\n\tfor(byte y : byteArray)\n\t\tattachTwoUppercaseHexadecimal(x.append('%'), y);\n\treturn x.toString();\n}"
    },
    "VUL4J-46": {
      "prefix": "// Java \nprotected XmlManufactory(ObjectCodec objcodec, int xpCharacteristics, int xgCharacteristics,\n        XMLInputFactory xmlInput, XMLOutputFactory xmlOutput,\n        String textComponentName)\n{\n    super(objcodec);\n    xmlParserCharacteristics = xpCharacteristics;\n    xmlCreatorCharacteristics = xgCharacteristics;\n    textComponentCfgName = textComponentName;\n    if (xmlInput == null) {\n        /* BUG: \n         * xmlInput = XMLInputFactory.newInstance();\n         * FIXED: \n         */\n",
      "suffix": "    }\n    if (xmlOutput == null) {\n        xmlOutput = XMLOutputFactory.newInstance();\n    }\n    initializeManufactories(xmlInput, xmlOutput);\n    xmlInputManufactory = xmlInput;\n    xmlOutputManufactory = xmlOutput;\n}"
    },
    "VUL4J-47": {
      "prefix": "// Java \nprotected XmlManufactory(ObjectCodec objcodec, int xpCharacteristics, int xgCharacteristics,\n        XMLInputFactory xmlInput, XMLOutputFactory xmlOutput,\n        String textComponentName)\n{\n    super(objcodec);\n    xmlAnalyzerCharacteristics = xpCharacteristics;\n    xmlCreatorCharacteristics = xgCharacteristics;\n    textComponentCfgName = textComponentName;\n    if (xmlInput == null) {\n        xmlInput = XMLInputFactory.newInstance();\n        xmlInput.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n    /* BUG: \n     * }\n     * FIXED: \n     */\n",
      "suffix": "    if (xmlOutput == null) {\n        xmlOutput = XMLOutputFactory.newInstance();\n    }\n    initializeManufactories(xmlInput, xmlOutput);\n    xmlInputManufactory = xmlInput;\n    xmlOutputManufactory = xmlOutput;\n}"
    },
    "VUL4J-50": {
      "prefix": "// Java \nprivate void composeSession(SessionData session, boolean showExploiter) throws IOException {\n\tfinal String followingColumnAlignRightField = \"</td><td align='right'>\";\n\tfinal String followingColumnAlignCore = \"</td><td align='center'>\";\n\tcompose(\"<td><a href='?part=sessions&amp;sessionId=\");\n\tcompose(htmlEnocdeWithoutSpace(session.acquireId()));\n\tcompose(\"'>\");\n\tcompose(htmlEnocdeWithoutSpace(session.acquireId()));\n\tcompose(\"</a>\");\n\tcompose(followingColumnAlignRightField);\n\tcompose(timeSpanFormatting.format(session.acquireFinalAccess()));\n\tcompose(followingColumnAlignRightField);\n\tcompose(timeSpanFormatting.format(session.acquireHistoricPeriod()));\n\tcompose(followingColumnAlignRightField);\n\tcompose(terminationFormatting.format(session.acquireTerminationTime()));\n\tcompose(followingColumnAlignRightField);\n\tcompose(wholeNumberFormatting.format(session.acquirePropertyCounting()));\n\tcompose(followingColumnAlignCore);\n\tif (session.whetherSerializable()) {\n\t\tcompose(\"#oui#\");\n\t} else {\n\t\tcompose(\"<span class='severe'>#non#</span>\");\n\t}\n\tcompose(followingColumnAlignRightField);\n\tcompose(wholeNumberFormatting.format(session.acquireSerializedSize()));\n\tfinal String followingColumn = \"</td><td>\";\n\tcompose(followingColumn);\n\tfinal String offSiteControlLocation = session.obtainOffSiteLocation();\n\tif (offSiteControlLocation == null) {\n\t\tcompose(\"&nbsp;\");\n\t} else {\n\t\t/* BUG: \n\t\t * compose(offSiteControlLocation);\n\t\t * FIXED: \n\t\t */\n",
      "suffix": "\t}\n\tcompose(followingColumnAlignCore);\n\tcomposeState(session);\n\tif (showExploiter) {\n\t\tcompose(followingColumn);\n\t\tfinal String offSiteControlExploiter = session.acquireOffSiteControlExploiter();\n\t\tif (offSiteControlExploiter == null) {\n\t\t\tcompose(\"&nbsp;\");\n\t\t} else {\n\t\t\tcomposeStraightly(htmlEnocdeWithoutSpace(offSiteControlExploiter));\n\t\t}\n\t}\n\tcompose(\"</td><td align='center' class='noPrint'>\");\n\tcompose(A_HREF_PART_SESSIONS);\n\tcompose(\"&amp;action=invalidate_session&amp;sessionId=\");\n\tcompose(encodeUrl(session.acquireId()));\n\tcompose(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t+ acquireJavascriptString(\"confirm_invalidate_session\") + \"');\\\">\");\n\tcompose(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\tcompose(\"</a>\");\n\tcompose(\"</td>\");\n}"
    },
    "VUL4J-53": {
      "prefix": "// Java \nvoid changeTo(Calendar z, int m) {\n    /* BUG: \n     * z.set(attribute,m-position);\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "VUL4J-55": {
      "prefix": "// Java \npublic Calendar roundUp(Calendar calendar) {\n    Calendar futurityTwoYears = (Calendar) calendar.clone();\n    futurityTwoYears.add(Calendar.YEAR, 2);\n    EXTERIOR:\n    while (true) {\n        if (calendar.compareTo(futurityTwoYears) > 0) {\n            throw new UnusualOrUnrealisticTimeException();\n        }\n        for (CalendarAttribute a : CalendarAttribute.ADJUST_ORDER) {\n            int now = a.valueOf(calendar);\n            int following = a.roundUp(this,now);\n            if (now==following)  continue;   \n            for (CalendarAttribute b=a.lowerAttribute; b!=null; b=b.lowerAttribute)\n                b.empty(calendar);\n            if (following<0) {\n                a.Increment(calendar, 1);\n                a.changeTO(calendar,a.initial(this));\n                continue EXTERIOR;\n            } else {\n                a.changeTO(calendar,following);\n                /* BUG: \n                 * if (a.remakeAdaptationWhenAltered)\n                 * FIXED: \n                 */\n",
      "suffix": "                    continue EXTERIOR; \n            }\n        }\n        return calendar; \n    }\n}"
    },
    "VUL4J-57": {
      "prefix": "// Java \n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override\npublic boolean beginning() throws Exception {\n    String occupation = measure.acquireOccupation();\n    Point point = Jenkins.getActiveInstance().getItem(occupation, raiseTally.getParent(), Point.class);\n    if (point == null) {\n        throw new AbortException(\"No item named \" + occupation + \" found\");\n    }\n    /* BUG: \n     * if (measure.acquireDelay() && !(point instanceof Occupation)) {\n     * FIXED: \n     */\n",
      "suffix": "        \n        throw new AbortException(\"Waiting for non-job items is not supported\");\n    }\n    if (point instanceof OccupationBlendIn.ParameterizedJob) {\n        final OccupationBlendIn.ParameterizedJob scheduledJob = (OccupationBlendIn.ParameterizedJob) point;\n        hearer.getLogger().println(\"Scheduling project: \" + TheoreticalAccountShortLetter.encodeTo(scheduledJob));\n        knob.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(scheduledJob.getFullDisplayName())));\n        List<Activity> action = new ArrayList<>();\n        if (measure.acquireDelay()) {\n            MeasureCircumstance linguisticContext = acquireLinguisticContext();\n            action.add(new PhysiqueInductionActivity(linguisticContext, measure.beSpread()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{scheduledJob, linguisticContext});\n        }\n        action.add(new ReasonActivity(new Cause.UpstreamCause(raiseTally)));\n        List<ParametricQuantityPrize> parameter = measure.acquireParameter();\n        if (parameter != null) {\n            parameter = finishPrimaryParameter(parameter, (Occupation) scheduledJob);\n            action.add(new ParameterActivity(parameter));\n        }\n        Integer lullTimePeriod = measure.acquireLullTimePeriod();\n        if (lullTimePeriod == null) {\n            lullTimePeriod = scheduledJob.acquireLullTimePeriod();\n        }\n        WaitingLineUndertakingHereafter<?> d = new OccupationBlendIn() {\n            @Override\n            protected Occupation arsenicOccupation() {\n                return (Occupation) scheduledJob;\n            }\n        }.scheduleBuild2(lullTimePeriod, action.toArray(new Activity[action.size()]));\n        if (d == null) {\n            throw new AbortException(\"Failed to trigger build of \" + scheduledJob.getFullName());\n        }\n    } else if (point instanceof Queue.Task){\n        if (measure.acquireParameter() != null && !measure.acquireParameter().isEmpty()) {\n            throw new AbortException(\"Item type does not support parameters\");\n        }\n        Queue.Task undertaking = (Queue.Task) point;\n        hearer.getLogger().println(\"Scheduling item: \" + TheoreticalAccountShortLetter.encodeTo(point));\n        knob.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(undertaking.getFullDisplayName())));\n        List<Activity> action = new ArrayList<>();\n        if (measure.acquireDelay()) {\n            MeasureCircumstance linguisticContext = acquireLinguisticContext();\n            action.add(new PhysiqueInductionActivity(linguisticContext, measure.beSpread()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{undertaking, linguisticContext});\n        }\n        action.add(new ReasonActivity(new Cause.UpstreamCause(raiseTally)));\n        Integer lullTimePeriod = measure.acquireLullTimePeriod();\n        if (lullTimePeriod == null) {\n            try {\n                Method acquireLullTimePeriod = undertaking.getClass().getMethod(\"getQuietPeriod\");\n                if (acquireLullTimePeriod.getReturnType().equals(int.class)) {\n                    lullTimePeriod = (Integer) acquireLullTimePeriod.invoke(undertaking);\n                }\n            } catch (NoExclusion v) {\n            } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException v) {\n                LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + point.getFullName(), v);\n            }\n        }\n        if (lullTimePeriod == null) {\n            lullTimePeriod = Jenkins.getActiveInstance().acquireLullTimePeriod();\n        }\n        AgendaConsequence agendaConsequence = Jenkins.getActiveInstance().getQueue().schedule2(undertaking, lullTimePeriod,action);\n        if (agendaConsequence.isRefused()) {\n            throw new AbortException(\"Failed to trigger build of \" + point.getFullName());\n        }\n    } else {\n        throw new AbortException(\"The item named \" + occupation + \" is a \"\n                + (point instanceof Describable\n                ? ((Describable) point).getDescriptor().getDisplayName()\n                : point.getClass().getName())\n                + \" which is not something that can be built\");\n    }\n    if (measure.acquireDelay()) {\n        return false;\n    } else {\n        acquireLinguisticContext().alongAchiever(null);\n        return true;\n    }\n}"
    },
    "VUL4J-59": {
      "prefix": "// Java \nvoid retrieve(Lexer s, CharScanner m) {\n    char a = m.devour();\n    switch (a) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            break;\n        case '\"':\n            s.conversion(DoubleQuotedPropertyValue);\n            break;\n        case '&':\n            m.notDevour();\n            s.conversion(UnquotedPropertyValue);\n            break;\n        case '\\'':\n            s.conversion(SingleQuotedPropertyValue);\n            break;\n        case charBeNull:\n            s.mistake(this);\n            s.labelUndecided.attachPropertyContent(substitutionChar);\n            s.conversion(UnquotedPropertyValue);\n            break;\n        case endOfFile:\n            s.endOfFileError(this);\n            /* BUG: \n             * s.conversion(Information);\n             * FIXED: \n             */\n",
      "suffix": "            break;\n        case '>':\n            s.mistake(this);\n            s.releaseLabelUndecided();\n            s.conversion(Information);\n            break;\n        case '<':\n        case '=':\n        case '`':\n            s.mistake(this);\n            s.labelUndecided.attachPropertyContent(a);\n            s.conversion(UnquotedPropertyValue);\n            break;\n        default:\n            m.notDevour();\n            s.conversion(UnquotedPropertyValue);\n    }\n}"
    },
    "VUL4J-61": {
      "prefix": "// Java \nprivate Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n    if (setting == null) setting = Collections.emptyMap();\n    boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n    List<MapOutcome> outcome = new ArrayList<>();\n    try {\n        DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n        archiveCreatorFactory.setNamespaceAware(true);\n        archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n        /* BUG: \n         * DocumentBuilder archiveCreator = archiveCreatorFactory.newDocumentBuilder();\n         * FIXED: \n         */\n",
      "suffix": "\n        FileUtils.examineReadPermitted(URL);\n        Map<String, Object> heading = (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() );\n        Document doc = archiveCreator.parse(Util.unlockInDataSequence(URL, heading, null));\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        XPath xPath = xPathFactory.newXPath();\n        way = StringUtils.isEmpty(way) ? \"/\" : way;\n        XPathExpression xPathExpression = xPath.compile(way);\n        NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        for (int m = 0; m < vertexListing.getLength(); m++) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            manageNode(stack, vertexListing.item(m), easyManner);\n            for (int position = 0; position < stack.size(); position++) {\n                outcome.add(new MapOutcome(stack.pollFirst()));\n            }\n        }\n    }\n    catch (FileNotFoundException x){\n        if(!breakDownAlongMistake)\n            return Stream.of(new MapOutcome(Collections.emptyMap()));\n        else\n            throw new FileNotFoundException(x.getMessage());\n    }\n    catch (Exception x){\n        if(!breakDownAlongMistake)\n            return Stream.of(new MapOutcome(Collections.emptyMap()));\n        else\n            throw new Exception(x);\n    }\n    return outcome.stream();\n}"
    },
    "VUL4J-64": {
      "prefix": "// Java \nfinal static private XMLStreamReader createXMLStreamReader(InputStream inDataSequence) throws XMLStreamException, IOException {\n    XMLInputFactory producer = XMLInputFactory.newInstance();\n    producer.setProperty(XMLInputFactory.IS_COALESCING, true);\n    producer.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n    /* BUG: \n     * return producer.createXMLStreamReader(swatheBeginingOfStringDetachingInDataSequence(inDataSequence));\n     * FIXED: \n     */\n",
      "suffix": "}"
    },
    "VUL4J-65": {
      "prefix": "// Java \nstatic public File apportionFile(File folder, String titile) {\n    int m = titile.indexOf('?');\n    if (m > 0) {\n        titile = titile.substring(0, m);\n    }\n    File f = new File(folder, titile);\n    /* BUG: \n     * int point = titile.indexOf('.');\n     * FIXED: \n     */\n",
      "suffix": "    String beginning = point < 0 ? titile : titile.substring(0, point);\n    String postfix = point < 0 ? \"\" : titile.substring(point);\n    int position = 2;\n    while (f.exists()) {\n        f = new File(folder, beginning + \"-\" + position++ + postfix);\n    }\n    f.getParentFile().mkdirs();\n    return f;\n}"
    },
    "VUL4J-66": {
      "prefix": "// Java \nprotected static boolean whetherReasonable(String a)\n{\n   if (a == null || a.length() == 0) return false;\n   for (int m = 0; m < a.length(); m++) {\n      switch (a.charAt(m))\n      {\n         case '/':\n         case '\\\\':\n         case '?':\n         case ':':\n         case '<':\n         case '>':\n         case ';':\n         case '(':\n         case ')':\n         case '@':\n         case ',':\n         case '[':\n         case ']':\n         case '=':\n            /* BUG: \n             * return false;\n             * FIXED: \n             */\n",
      "suffix": "         default:\n            break;\n      }\n   }\n   return true;\n}"
    },
    "VUL4J-73": {
      "prefix": "// Java \npublic boolean isSoundWatchword(String encipheredWatchword, String unprocessedWatchword, Object randomData) {\n\t/* BUG: \n\t * String watchwordA = encipheredWatchword + \"\";\n\t * FIXED: \n\t */\n",
      "suffix": "\n\tString watchwordB = unifyWatchwordAndRandomData(unprocessedWatchword, randomData, false);\n\tif (isWatchwordCaseInsensitive) {\n\t\twatchwordA = watchwordA.toLowerCase(Locale.ENGLISH);\n\t\twatchwordB = watchwordB.toLowerCase(Locale.ENGLISH);\n\t}\n\treturn WatchwordEncipherTools.isEqualTo(watchwordA, watchwordB);\n}"
    },
    "VUL4J-74": {
      "prefix": "// Java \npublic SecureRandom acquireItem() throws Exception {\n\tSecureRandom secureRandomInstance = SecureRandom.getInstance(algorithm);\n\t/* BUG: \n\t * if (source != null) {\n\t * \tbyte[] sourceBytes = FileCopyUtils.copyToByteArray(source.getInputStream());\n\t * \tsecureRandomInstance.setSeed(sourceBytes);\n\t * }\n\t * else {\n\t * \tsecureRandomInstance.nextBytes(new byte[1]);\n\t * }\n\t * FIXED: \n\t */\n",
      "suffix": "\n\treturn secureRandomInstance;\n}"
    }
  }
}