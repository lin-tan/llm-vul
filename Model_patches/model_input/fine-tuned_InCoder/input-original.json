{
  "config": "finetune",
  "data": {
    "Netty-1": {
      "loc": "11-11",
      "input": "private void splitHeader(AppendableCharSequence sb) {\n    final int length = sb.length();\n    int nameStart;\n    int nameEnd;\n    int colonEnd;\n    int valueStart;\n    int valueEnd;\n    nameStart = findNonWhitespace(sb, 0);\n    for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n        char ch = sb.charAtUnsafe(nameEnd);\n// buggy lines start:\n        if (ch == ':' || Character.isWhitespace(ch)) {\n// buggy lines end\n            break;\n        }\n    }\n    for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n        if (sb.charAtUnsafe(colonEnd) == ':') {\n            colonEnd ++;\n            break;\n        }\n    }\n    name = sb.subStringUnsafe(nameStart, nameEnd);\n    valueStart = findNonWhitespace(sb, colonEnd);\n    if (valueStart == length) {\n        value = EMPTY_VALUE;\n    } else {\n        valueEnd = findEndOfString(sb);\n        value = sb.subStringUnsafe(valueStart, valueEnd);\n    }\n}\n// fixed lines:\n"
    },
    "Netty-2": {
      "loc": "16-16",
      "input": "private void splitHeader(AppendableCharSequence sb) {\n    final int length = sb.length();\n    int nameStart;\n    int nameEnd;\n    int colonEnd;\n    int valueStart;\n    int valueEnd;\n    nameStart = findNonWhitespace(sb, 0);\n    for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n        char ch = sb.charAtUnsafe(nameEnd);\n        if (ch == ':' ||\n                (!isDecodingRequest() && Character.isWhitespace(ch))) {\n            break;\n        }\n    }\n// buggy lines start:\n    for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n// buggy lines end\n        if (sb.charAtUnsafe(colonEnd) == ':') {\n            colonEnd ++;\n            break;\n        }\n    }\n    name = sb.subStringUnsafe(nameStart, nameEnd);\n    valueStart = findNonWhitespace(sb, colonEnd);\n    if (valueStart == length) {\n        value = EMPTY_VALUE;\n    } else {\n        valueEnd = findEndOfString(sb);\n        value = sb.subStringUnsafe(valueStart, valueEnd);\n    }\n}\n// fixed lines:\n"
    },
    "Jenkins-1": {
      "loc": "4-5",
      "input": "@Exported(inline=true)\npublic Map<String,Object> getMonitorData() {\n    Map<String,Object> r = new HashMap<String, Object>();\n// buggy lines start:\n    for (NodeMonitor monitor : NodeMonitor.getAll())\n        r.put(monitor.getClass().getName(),monitor.data(this));\n// buggy lines end\n    return r;\n}\n// fixed lines:\n"
    },
    "Jenkins-2": {
      "loc": "3-6",
      "input": "@Exported(name=\"jobs\")\npublic List<TopLevelItem> getItems() {\n// buggy lines start:\n    if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n        authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n        return new ArrayList(items.values());\n    }\n// buggy lines end\n\n    List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n    for (TopLevelItem item : items.values()) {\n        if (item.hasPermission(Item.READ))\n            viewableItems.add(item);\n    }\n    return viewableItems;\n}\n// fixed lines:\n"
    },
    "Jenkins-3": {
      "loc": "1890-1890",
      "input": "    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n// buggy lines start:\n                protected Collection<View> all() { return views; }\n// buggy lines end\n            });\n    }\n// fixed lines:\n"
    },
    "Halo-1": {
      "loc": "4-4",
      "input": "public static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n    Assert.notNull(parentPath, \"Parent path must not be null\");\n    Assert.notNull(pathToCheck, \"Path to check must not be null\");\n// buggy lines start:\n    if (pathToCheck.startsWith(parentPath.normalize())) {\n// buggy lines end\n        return;\n    }\n    throw new ForbiddenException(\"You do not have permission to access \" + pathToCheck).setErrorData(pathToCheck);\n}\n// fixed lines:\n"
    },
    "Retrofit-1": {
      "loc": "3-3",
      "input": "JaxbResponseConverter(JAXBContext context, Class<T> type) {\n  this.context = context;\n// buggy lines start:\n  this.type = type;\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "Quartz-1": {
      "loc": "7-7",
      "input": "protected void initDocumentParser() throws ParserConfigurationException  {\n    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setNamespaceAware(true);\n    docBuilderFactory.setValidating(true);\n    docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaLanguage\", \"http://www.w3.org/2001/XMLSchema\");\n    docBuilderFactory.setAttribute(\"http://java.sun.com/xml/jaxp/properties/schemaSource\", resolveSchemaSource());\n// buggy lines start:\n    docBuilder = docBuilderFactory.newDocumentBuilder();\n// buggy lines end\n    \n    docBuilder.setErrorHandler(this);\n    NamespaceContext nsContext = new NamespaceContext()\n    {\n      public String getNamespaceURI(String prefix)\n      {\n          if (prefix == null)\n              throw new IllegalArgumentException(\"Null prefix\");\n          if (XMLConstants.XML_NS_PREFIX.equals(prefix))\n              return XMLConstants.XML_NS_URI;\n          if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix))\n              return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;\n          if (\"q\".equals(prefix))\n              return QUARTZ_NS;\n          return XMLConstants.NULL_NS_URI;\n      }\n      public Iterator<?> getPrefixes(String namespaceURI)\n      {\n          throw new UnsupportedOperationException();\n      }\n      public String getPrefix(String namespaceURI)\n      {\n          throw new UnsupportedOperationException();\n      }\n    }; \n    xpath = XPathFactory.newInstance().newXPath();\n    xpath.setNamespaceContext(nsContext);\n}\n// fixed lines:\n"
    },
    "Flow-1": {
      "loc": "7-8",
      "input": "public boolean serveDevModeRequest(HttpServletRequest request,\n        HttpServletResponse response) throws IOException {\n    if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {\n        return false;\n    }\n    String requestFilename = request.getPathInfo();\n// buggy lines start:\n    if (HandlerHelper.isPathUnsafe(requestFilename)) {\n        getLogger().info(HandlerHelper.UNSAFE_PATH_ERROR_MESSAGE_PATTERN,\n// buggy lines end\n                requestFilename);\n        response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        return true;\n    }\n    if(APP_THEME_PATTERN.matcher(requestFilename).find()) {\n        requestFilename = \"/VAADIN/static\" + requestFilename;\n    }\n    HttpURLConnection connection = prepareConnection(requestFilename,\n            request.getMethod());\n    Enumeration<String> headerNames = request.getHeaderNames();\n    while (headerNames.hasMoreElements()) {\n        String header = headerNames.nextElement();\n        connection.setRequestProperty(header,\n                \"Connect\".equals(header) ? \"close\"\n                        : request.getHeader(header));\n    }\n    getLogger().debug(\"Requesting resource to webpack {}\",\n            connection.getURL());\n    int responseCode = connection.getResponseCode();\n    if (responseCode == HTTP_NOT_FOUND) {\n        getLogger().debug(\"Resource not served by webpack {}\",\n                requestFilename);\n        return false;\n    }\n    getLogger().debug(\"Served resource by webpack: {} {}\", responseCode,\n            requestFilename);\n    connection.getHeaderFields().forEach((header, values) -> {\n        if (header != null) {\n            response.addHeader(header, values.get(0));\n        }\n    });\n    if (responseCode == HTTP_OK) {\n        writeStream(response.getOutputStream(),\n                connection.getInputStream());\n    } else if (responseCode < 400) {\n        response.setStatus(responseCode);\n    } else {\n        response.sendError(responseCode);\n    }\n    response.getOutputStream().close();\n    return true;\n}\n// fixed lines:\n"
    },
    "Flow-2": {
      "loc": "14-18",
      "input": "@Override\npublic int setErrorParameter(BeforeEnterEvent event,\n        ErrorParameter<NotFoundException> parameter) {\n    String path = event.getLocation().getPath();\n    String additionalInfo = \"\";\n    if (parameter.hasCustomMessage()) {\n        additionalInfo = \"Reason: \" + parameter.getCustomMessage();\n    }\n    path = Jsoup.clean(path, Whitelist.none());\n    additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n    boolean productionMode = event.getUI().getSession().getConfiguration()\n            .isProductionMode();\n    String template = getErrorHtml(productionMode);\n// buggy lines start:\n    template = template.replace(\"{{path}}\", path);\n    template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n    if (template.contains(\"{{routes}}\")) {\n        template = template.replace(\"{{routes}}\", getRoutes(event));\n    }\n// buggy lines end\n\n    getElement().appendChild(new Html(template).getElement());\n    return HttpServletResponse.SC_NOT_FOUND;\n}\n// fixed lines:\n"
    },
    "BC-Java-1": {
      "loc": "6-6",
      "input": "private BigInteger[] derDecode(\n    byte[]  encoding)\n    throws IOException\n{\n    ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n// buggy lines start:\n    return new BigInteger[]{\n// buggy lines end\n        ((ASN1Integer)s.getObjectAt(0)).getValue(),\n        ((ASN1Integer)s.getObjectAt(1)).getValue()\n    };\n}\n// fixed lines:\n"
    },
    "Json-sanitizer-1": {
      "loc": "28-34",
      "input": "private void sanitizeString(int start, int end) {\n  boolean closed = false;\n  for (int i = start; i < end; ++i) {\n    char ch = jsonish.charAt(i);\n    switch (ch) {\n      case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n      case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n      case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n      case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (i == start) {\n          if (ch == '\\'') { replace(i, i + 1, '\"'); }\n        } else {\n          if (i + 1 == end) {\n            char startDelim = jsonish.charAt(start);\n            if (startDelim != '\\'') {\n              startDelim = '\"';\n            }\n            closed = startDelim == ch;\n          }\n          if (closed) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else if (ch == '\"') {\n            insert(i, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n            && 's' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n          insert(i, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n            && '>' == jsonish.charAt(i + 2)) {\n          replace(i, i + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (i + 1 == end) {\n          elide(i, i + 1);\n          break;\n        }\n        char sch = jsonish.charAt(i + 1);\n        switch (sch) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++i;\n            break;\n          case 'v':  \n            replace(i, i + 2, \"\\\\u0008\");\n            ++i;\n            break;\n          case 'x':\n            if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n              replace(i, i + 2, \"\\\\u00\");  \n              i += 3;\n              break;\n            }\n            elide(i, i + 1);\n            break;\n          case 'u':\n            if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                && isHexAt(i + 4) && isHexAt(i + 5)) {\n              i += 5;\n              break;\n            }\n            elide(i, i + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalEnd = i + 1;\n            if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n              ++octalEnd;\n              if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n              }\n              int value = 0;\n              for (int j = i; j < octalEnd; ++j) {\n                value = (value << 3) | (jsonish.charAt(j) - '0');\n              }\n              replace(i + 1, octalEnd, \"u00\");\n              appendHex(value, 2);\n            }\n            i = octalEnd - 1;\n            break;\n          default:\n            elide(i, i + 1);\n            break;\n        }\n        break;\n      default:\n        if (ch < 0x20) {\n          if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n        } else if (ch < 0xd800) {  \n          continue;\n        } else if (ch < 0xe000) {  \n          if (Character.isHighSurrogate(ch) && i+1 < end\n              && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n            ++i;  \n            continue;\n          }\n        } else if (ch <= 0xfffd) {  \n          continue;\n        }\n        replace(i, i + 1, \"\\\\u\");\n        for (int j = 4; --j >= 0;) {\n          sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!closed) { insert(end, '\"'); }\n}\n// fixed lines:\n"
    },
    "Jinjava-1":{
      "loc": "23-23",
      "input": "  private static final Set<String> RESTRICTED_METHODS = ImmutableSet.<String> builder()\n      .add(\"clone\")\n      .add(\"hashCode\")\n// buggy lines start:\n      .add(\"notify\")\n// buggy lines end\n      .add(\"notifyAll\")\n      .add(\"wait\")\n      .build();\n// fixed lines:\n"
    },  
    "Ratpack-1": {
      "loc": "32-32",
      "input": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n  RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody != null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n// buggy lines start:\n  HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n// buggy lines end\n  MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n  AtomicBoolean transmitted = new AtomicBoolean(false);\n  DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n  ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n  Action<Action<Object>> subscribeHandler = thing -> {\n    transmitted.set(true);\n    ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n  };\n  DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n    applicationConstants,\n    request,\n    channel,\n    responseTransmitter,\n    subscribeHandler\n  );\n  Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n  requestConstants.response = response;\n  DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n    if (!transmitted.get()) {\n      Handler lastHandler = requestConstants.handler;\n      StringBuilder description = new StringBuilder();\n      description\n        .append(\"No response sent for \")\n        .append(request.getMethod().getName())\n        .append(\" request to \")\n        .append(request.getUri());\n      if (lastHandler != null) {\n        description.append(\" (last handler: \");\n        if (lastHandler instanceof DescribingHandler) {\n          ((DescribingHandler) lastHandler).describeTo(description);\n        } else {\n          DescribingHandlers.describeTo(lastHandler, description);\n        }\n        description.append(\")\");\n      }\n      String message = description.toString();\n      LOGGER.warn(message);\n      response.getHeaders().clear();\n      ByteBuf body;\n      if (development) {\n        CharBuffer charBuffer = CharBuffer.wrap(message);\n        body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n        response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n      } else {\n        body = Unpooled.EMPTY_BUFFER;\n      }\n      response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n      responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n    }\n  });\n}\n// fixed lines:\n"
    },
    "Pulsar-1": {
      "loc": "11-11",
      "input": "protected void internalGetMessageById(AsyncResponse asyncResponse, long ledgerId, long entryId,\n                                          boolean authoritative) {\n    try {\n        validateTopicOwnership(topicName, authoritative);\n        validateTopicOperation(topicName, TopicOperation.PEEK_MESSAGES);\n        if (topicName.isGlobal()) {\n            validateGlobalNamespaceOwnership(namespaceName);\n        }\n        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n        ManagedLedgerImpl ledger = (ManagedLedgerImpl) topic.getManagedLedger();\n// buggy lines start:\n        ledger.asyncReadEntry(new PositionImpl(ledgerId, entryId), new AsyncCallbacks.ReadEntryCallback() {\n// buggy lines end\n            @Override\n            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n                asyncResponse.resume(new RestException(exception));\n            }\n            @Override\n            public void readEntryComplete(Entry entry, Object ctx) {\n                try {\n                    asyncResponse.resume(generateResponseWithEntry(entry));\n                } catch (IOException exception) {\n                    asyncResponse.resume(new RestException(exception));\n                } finally {\n                    if (entry != null) {\n                        entry.release();\n                    }\n                }\n            }\n        }, null);\n    } catch (NullPointerException npe) {\n        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Message not found\"));\n    } catch (Exception exception) {\n        log.error(\"[{}] Failed to get message with ledgerId {} entryId {} from {}\",\n                clientAppId(), ledgerId, entryId, topicName, exception);\n        asyncResponse.resume(new RestException(exception));\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-1": {
      "loc": "49-49",
      "input": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n    final JSONLexer lexer = parser.lexer;\n    if (lexer.token() == JSONToken.NULL) {\n        lexer.nextToken(JSONToken.COMMA);\n        return null;\n    }\n    if (lexer.token() == JSONToken.LITERAL_STRING) {\n        byte[] bytes = lexer.bytesValue();\n        lexer.nextToken(JSONToken.COMMA);\n        return (T) bytes;\n    }\n    Class componentClass;\n    Type componentType;\n    if (type instanceof GenericArrayType) {\n        GenericArrayType clazz = (GenericArrayType) type;\n        componentType = clazz.getGenericComponentType();\n        if (componentType instanceof TypeVariable) {\n            TypeVariable typeVar = (TypeVariable) componentType;\n            Type objType = parser.getContext().type;\n            if (objType instanceof ParameterizedType) {\n                ParameterizedType objParamType = (ParameterizedType) objType;\n                Type objRawType = objParamType.getRawType();\n                Type actualType = null;\n                if (objRawType instanceof Class) {\n                    TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\n                    for (int i = 0; i < objTypeParams.length; ++i) {\n                        if (objTypeParams[i].getName().equals(typeVar.getName())) {\n                            actualType = objParamType.getActualTypeArguments()[i];\n                        }\n                    }\n                }\n                if (actualType instanceof Class) {\n                    componentClass = (Class) actualType;\n                } else {\n                    componentClass = Object.class;\n                }\n            } else {\n                componentClass = TypeUtils.getClass(typeVar.getBounds()[0]);\n            }\n        } else {\n            componentClass = TypeUtils.getClass(componentType);\n        }\n    } else {\n        Class clazz = (Class) type;\n        componentType = componentClass = clazz.getComponentType();\n    }\n    JSONArray array = new JSONArray();\n// buggy lines start:\n    parser.parseArray(componentClass, array, fieldName);\n// buggy lines end\n\n    return (T) toObjectArray(parser, componentClass, array);\n}\n// fixed lines:\n"
    },
    "VUL4J-3": {
      "loc": "24-24",
      "input": "@Converter\npublic SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n    InputSource inputSource;\n    if (source.getReader() != null) {\n        inputSource = new InputSource(source.getReader());\n    } else {\n        inputSource = new InputSource(source.getInputStream());\n    }\n    inputSource.setSystemId(source.getSystemId());\n    inputSource.setPublicId(source.getPublicId());\n    XMLReader xmlReader = null;\n    SAXParserFactory sfactory = null;\n    try {\n        if (exchange != null) {\n            sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n        }\n        if (sfactory == null) {\n            sfactory = SAXParserFactory.newInstance();\n            try {\n                sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            } catch (Exception e) {\n                LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n            }\n// buggy lines start:\n        }\n// buggy lines end\n        sfactory.setNamespaceAware(true);\n        SAXParser parser = sfactory.newSAXParser();\n        xmlReader = parser.getXMLReader();\n    } catch (Exception ex) {\n        LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n    }\n    return new SAXSource(xmlReader, inputSource);\n}\n// fixed lines:\n"
    },
    "VUL4J-4": {
      "loc": "16-28",
      "input": "protected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n    if (body == null) {\n        return null;\n    }\n    Object answer = null;\n    Class<?> type = getDocumentType();\n    Exception cause = null;\n    if (type != null) {\n        try {\n            answer = exchange.getContext().getTypeConverter().convertTo(type, exchange, body);\n        } catch (Exception e) {\n            cause = e;\n        }\n    }\n// buggy lines start:\n    if (answer == null) {\n        if (body instanceof WrappedFile) {\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, body);\n            answer = new InputSource(is);\n        } else if (body instanceof BeanInvocation) {\n            BeanInvocation bi = exchange.getContext().getTypeConverter().convertTo(BeanInvocation.class, exchange, body);\n            if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {\n                answer = null;\n            }\n        } else if (body instanceof String) {\n            answer = new InputSource(new StringReader((String) body));\n        }\n    }\n// buggy lines end\n    if (type == null && answer == null) {\n        answer = body;\n    } else if (answer == null) {\n        if (cause != null) {\n            throw cause;\n        } else {\n            throw new NoTypeConversionAvailableException(body, type);\n        }\n    }\n    return answer;\n}\n// fixed lines:\n"
    },
    "VUL4J-5": {
      "loc": "3-3",
      "input": "private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n    throws IOException {\n// buggy lines start:\n    String targetDirPath = targetDirectory.getCanonicalPath();\n// buggy lines end\n    ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n    while (nextEntry != null) {\n        File f = new File(targetDirectory, nextEntry.getName());\n        if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n            throw new IOException(\"expanding \" + nextEntry.getName()\n                + \" would create file outside of \" + targetDirectory);\n        }\n        if (nextEntry.isDirectory()) {\n            if (!f.isDirectory() && !f.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + f);\n            }\n        } else {\n            File parent = f.getParentFile();\n            if (!parent.isDirectory() && !parent.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + parent);\n            }\n            try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                writer.writeEntryDataTo(nextEntry, o);\n            }\n        }\n        nextEntry = supplier.getNextReadableEntry();\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-6": {
      "loc": "10-10",
      "input": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n    this.format = ZipShort.getValue(data, offset);\n    this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n    this.bitlen = ZipShort.getValue(data, offset + 4);\n    this.flags = ZipShort.getValue(data, offset + 6);\n    this.rcount = ZipLong.getValue(data, offset + 8);\n    if (rcount > 0) {\n        this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n        this.hashSize = ZipShort.getValue(data, offset + 14);\n// buggy lines start:\n        for (int i = 0; i < this.rcount; i++) {\n// buggy lines end\n            for (int j = 0; j < this.hashSize; j++) {\n            }\n        }\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-7": {
      "loc": "16-16",
      "input": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (current.hasDataDescriptor) {\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n    final long csize = current.entry.getSize();\n    if (current.bytesRead >= csize) {\n        return -1;\n    }\n    if (buf.position() >= buf.limit()) {\n        buf.position(0);\n        final int l = in.read(buf.array());\n        if (l == -1) {\n// buggy lines start:\n            return -1;\n// buggy lines end\n        }\n        buf.limit(l);\n        count(l);\n        current.bytesReadFromStream += l;\n    }\n    int toRead = Math.min(buf.remaining(), length);\n    if ((csize - current.bytesRead) < toRead) {\n        toRead = (int) (csize - current.bytesRead);\n    }\n    buf.get(buffer, offset, toRead);\n    current.bytesRead += toRead;\n    return toRead;\n}\n// fixed lines:\n"
    },
    "VUL4J-8": {
      "loc": "27-27",
      "input": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharsetEncoder enc = newEncoder();\n    final CharBuffer cb = CharBuffer.wrap(name);\n    CharBuffer tmp = null;\n    ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n        if (res.isUnmappable() || res.isMalformed()) {\n            int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n            if (spaceForSurrogate > out.remaining()) {\n                int charCount = 0;\n                for (int i = cb.position() ; i < cb.limit(); i++) {\n                    charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                }\n                int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n            }\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(6);\n            }\n            for (int i = 0; i < res.length(); ++i) {\n                out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n            }\n        } else if (res.isOverflow()) {\n            int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n// buggy lines start:\n            out = ZipEncodingHelper.growBufferBy(out, increment);\n// buggy lines end\n        }\n    }\n    enc.encode(cb, out, true);\n    out.limit(out.position());\n    out.rewind();\n    return out;\n}\n// fixed lines:\n"
    },
    "VUL4J-10": {
      "loc": "4-4",
      "input": "private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException {\n    in.defaultReadObject();\n// buggy lines start:\n    OutputStream output = getOutputStream();\n// buggy lines end\n    if (cachedContent != null) {\n        output.write(cachedContent);\n    } else {\n        FileInputStream input = new FileInputStream(dfosFile);\n        IOUtils.copy(input, output);\n        dfosFile.delete();\n        dfosFile = null;\n    }\n    output.close();\n    cachedContent = null;\n}\n// fixed lines:\n"
    },
    "VUL4J-12": {
      "loc": "3-3",
      "input": "private int extend(int v, final int t) {\n    int vt = (1 << (t - 1));\n// buggy lines start:\n    while (v < vt) {\n// buggy lines end\n        vt = (-1 << t) + 1;\n        v += vt;\n    }\n    return v;\n}\n// fixed lines:\n"
    },
    "VUL4J-18": {
      "loc": "3-3",
      "input": "public String getForwardPage( HttpServletRequest request )\n{\n// buggy lines start:\n    return request.getPathInfo();\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "VUL4J-19": {
      "loc": "64-64",
      "input": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n// buggy lines start:\n        setCurrentAccessPermission(currentAccessPermission);\n// buggy lines end\n        \n        encryptionKey =\n            computeEncryptedKey(\n                password.getBytes(passwordCharset),\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    else\n    {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n    if (encryption.getVersion() == 4 || encryption.getVersion() == 5)\n    {\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null)\n        {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            setAES(COSName.AESV2.equals(cryptFilterMethod) || \n                   COSName.AESV3.equals(cryptFilterMethod));\n        }\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-20": {
      "loc": "6-6",
      "input": "public float[] toFloatArray()\n{\n    float[] retval = new float[size()];\n    for (int i = 0; i < size(); i++)\n    {\n// buggy lines start:\n        retval[i] = ((COSNumber)getObject( i )).floatValue();\n// buggy lines end\n    }\n    return retval;\n}\n// fixed lines:\n"
    },
    "VUL4J-22": {
      "loc": "6-10",
      "input": "public static String getContextPath(HttpServletRequest request) {\n    String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n    if (contextPath == null) {\n        contextPath = request.getContextPath();\n    }\n// buggy lines start:\n    if (\"/\".equals(contextPath)) {\n        contextPath = \"\";\n    }\n    return decodeRequestString(request, contextPath);\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "VUL4J-23": {
      "loc": "3-3",
      "input": "@Override\npublic String encodeForJSString(String source) {\n// buggy lines start:\n    return source == null ? null : Encode.forJavaScriptSource(source);\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "VUL4J-25": {
      "loc": "5-25",
      "input": "@Override\n@Nonnull\npublic String getValidHref(final String url) {\n    if (StringUtils.isNotEmpty(url)) {\n// buggy lines start:\n        try {\n            String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n            unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n            String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        } catch (UnsupportedEncodingException e) {\n            LOGGER.error(\"Unable to decode url: {}.\", url);\n        }\n// buggy lines end\n    }\n    return \"\";\n}\n// fixed lines:\n"
    },
    "VUL4J-26": {
      "loc": "16-16",
      "input": "public String getUrlRegex() {\n    if (StringUtils.isNotEmpty(urlRegexExpression)) {\n        return (String) parse(urlRegexExpression, String.class);\n    } else if (StringUtils.isNotEmpty(urlRegex)) {\n        return urlRegex;\n    } else {\n        return \"^(https?|ftp):\\\\/\\\\/\" +\n                \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                \"@)?(#?\" +\n                \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                \")(:\\\\d+)?\" +\n// buggy lines start:\n                \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n// buggy lines end\n                \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                \"?)?)?\" +\n                \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                \"$\";\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-30": {
      "loc": "7-7",
      "input": "public void validate(Object object) throws ValidationException {\n    String fieldName = getFieldName();\n    Object value = this.getFieldValue(fieldName, object);\n    if (value == null || value.toString().length() == 0) {\n        return;\n    }\n// buggy lines start:\n    if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n// buggy lines end\n        addFieldError(fieldName, object);\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-39": {
      "loc": "13-18",
      "input": "@Override\npublic String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (origin != null) {\n        sb.append(\"remoteAddress=\").append(origin);\n    }\n    if (clientId != null) {\n        if (sb.length() > 0) {\n            sb.append(\", \");\n        }\n        sb.append(\"clientId=\").append(clientId);\n    }\n// buggy lines start:\n    if (sessionId != null) {\n        if (sb.length() > 0) {\n            sb.append(\", \");\n        }\n        sb.append(\"sessionId=\").append(sessionId);\n    }\n// buggy lines end\n    return sb.toString();\n}\n// fixed lines:\n"
    },
    "VUL4J-40": {
      "loc": "15-15",
      "input": "public boolean isAllowed(HttpServletRequest request) throws IOException {\n    String requestBody = IOUtils.toString(request.getReader());\n    ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n    String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n    String zoneId = IdentityZoneHolder.get().getId();\n    ScimUser scimUserFromDb;\n    try {\n        scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n    } catch (ScimResourceNotFoundException e) {\n        return true;\n    }\n    if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n        return false;\n    }\n// buggy lines start:\n    if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n// buggy lines end\n        return false;\n    }\n    if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n        return false;\n    }\n    if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n        return false;\n    }\n    if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n        return false;\n    }\n    return true;\n}\n// fixed lines:\n"
    },
    "VUL4J-41": {
      "loc": "7-7",
      "input": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                            final String entryName, final Date entryDate, final boolean isDirectory,\n                            final Integer mode, String symlinkDestination )\n    throws IOException, ArchiverException\n{\n    final File f = FileUtils.resolveFile( dir, entryName );\n// buggy lines start:\n    try\n// buggy lines end\n    {\n        if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n        {\n            return;\n        }\n        final File dirF = f.getParentFile();\n        if ( dirF != null )\n        {\n            dirF.mkdirs();\n        }\n        if ( !StringUtils.isEmpty( symlinkDestination ) )\n        {\n            SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n        }\n        else if ( isDirectory )\n        {\n            f.mkdirs();\n        }\n        else\n        {\n            OutputStream out = null;\n            try\n            {\n                out = new FileOutputStream( f );\n                IOUtil.copy( compressedInputStream, out );\n                out.close();\n                out = null;\n            }\n            finally\n            {\n                IOUtil.close( out );\n            }\n        }\n        f.setLastModified( entryDate.getTime() );\n        if ( !isIgnorePermissions() && mode != null && !isDirectory )\n        {\n            ArchiveEntryUtils.chmod( f, mode );\n        }\n    }\n    catch ( final FileNotFoundException ex )\n    {\n        getLogger().warn( \"Unable to expand to file \" + f.getPath() );\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-43": {
      "loc": "5-5",
      "input": "public static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n\tthrows IOException\n{\n\tFile outFile = new File(destDir, entry.getName());\n// buggy lines start:\n\tif (entry.isDirectory()) {\n// buggy lines end\n\t\toutFile.mkdirs();\n\t}\n\telse {\n\t\toutFile.getParentFile().mkdirs();\n\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\tIOUtil.writeStream(in, outFile);\n\t\t}\n\t}\n}\n// fixed lines:\n"
    },
    "VUL4J-44": {
      "loc": "6-6",
      "input": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n// buggy lines start:\n\tif(UNENCODED_SET.contains(c))\n// buggy lines end\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n// fixed lines:\n"
    },
    "VUL4J-46": {
      "loc": "10-10",
      "input": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n        XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n        String nameForTextElem)\n{\n    super(oc);\n    _xmlParserFeatures = xpFeatures;\n    _xmlGeneratorFeatures = xgFeatures;\n    _cfgNameForTextElement = nameForTextElem;\n    if (xmlIn == null) {\n// buggy lines start:\n        xmlIn = XMLInputFactory.newInstance();\n// buggy lines end\n    }\n    if (xmlOut == null) {\n        xmlOut = XMLOutputFactory.newInstance();\n    }\n    _initFactories(xmlIn, xmlOut);\n    _xmlInputFactory = xmlIn;\n    _xmlOutputFactory = xmlOut;\n}\n// fixed lines:\n"
    },
    "VUL4J-47": {
      "loc": "12-12",
      "input": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n        XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n        String nameForTextElem)\n{\n    super(oc);\n    _xmlParserFeatures = xpFeatures;\n    _xmlGeneratorFeatures = xgFeatures;\n    _cfgNameForTextElement = nameForTextElem;\n    if (xmlIn == null) {\n        xmlIn = XMLInputFactory.newInstance();\n        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// buggy lines start:\n    }\n// buggy lines end\n    if (xmlOut == null) {\n        xmlOut = XMLOutputFactory.newInstance();\n    }\n    _initFactories(xmlIn, xmlOut);\n    _xmlInputFactory = xmlIn;\n    _xmlOutputFactory = xmlOut;\n}\n// fixed lines:\n"
    },
    "VUL4J-50": {
      "loc": "31-31",
      "input": "private void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\twrite(htmlEncodeButNotSpace(session.getId()));\n\twrite(\"'>\");\n\twrite(htmlEncodeButNotSpace(session.getId()));\n\twrite(\"</a>\");\n\twrite(nextColumnAlignRight);\n\twrite(durationFormat.format(session.getLastAccess()));\n\twrite(nextColumnAlignRight);\n\twrite(durationFormat.format(session.getAge()));\n\twrite(nextColumnAlignRight);\n\twrite(expiryFormat.format(session.getExpirationDate()));\n\twrite(nextColumnAlignRight);\n\twrite(integerFormat.format(session.getAttributeCount()));\n\twrite(nextColumnAlignCenter);\n\tif (session.isSerializable()) {\n\t\twrite(\"#oui#\");\n\t} else {\n\t\twrite(\"<span class='severe'>#non#</span>\");\n\t}\n\twrite(nextColumnAlignRight);\n\twrite(integerFormat.format(session.getSerializedSize()));\n\tfinal String nextColumn = \"</td><td>\";\n\twrite(nextColumn);\n\tfinal String remoteAddr = session.getRemoteAddr();\n\tif (remoteAddr == null) {\n\t\twrite(\"&nbsp;\");\n\t} else {\n// buggy lines start:\n\t\twrite(remoteAddr);\n// buggy lines end\n\t}\n\twrite(nextColumnAlignCenter);\n\twriteCountry(session);\n\tif (displayUser) {\n\t\twrite(nextColumn);\n\t\tfinal String remoteUser = session.getRemoteUser();\n\t\tif (remoteUser == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t}\n\t}\n\twrite(\"</td><td align='center' class='noPrint'>\");\n\twrite(A_HREF_PART_SESSIONS);\n\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\twrite(urlEncode(session.getId()));\n\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\twrite(\"</a>\");\n\twrite(\"</td>\");\n}\n// fixed lines:\n"
    },
    "VUL4J-53": {
      "loc": "2-2",
      "input": "void setTo(Calendar c, int i) {\n// buggy lines start:\n    c.set(field,i-offset);\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "VUL4J-55": {
      "loc": "21-21",
      "input": "public Calendar ceil(Calendar cal) {\n    Calendar twoYearsFuture = (Calendar) cal.clone();\n    twoYearsFuture.add(Calendar.YEAR, 2);\n    OUTER:\n    while (true) {\n        if (cal.compareTo(twoYearsFuture) > 0) {\n            throw new RareOrImpossibleDateException();\n        }\n        for (CalendarField f : CalendarField.ADJUST_ORDER) {\n            int cur = f.valueOf(cal);\n            int next = f.ceil(this,cur);\n            if (cur==next)  continue;   \n            for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                l.clear(cal);\n            if (next<0) {\n                f.rollUp(cal, 1);\n                f.setTo(cal,f.first(this));\n                continue OUTER;\n            } else {\n                f.setTo(cal,next);\n// buggy lines start:\n                if (f.redoAdjustmentIfModified)\n// buggy lines end\n                    continue OUTER; \n            }\n        }\n        return cal; \n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-57": {
      "loc": "9-9",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override\npublic boolean start() throws Exception {\n    String job = step.getJob();\n    Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n    if (item == null) {\n        throw new AbortException(\"No item named \" + job + \" found\");\n    }\n// buggy lines start:\n    if (step.getWait() && !(item instanceof Job)) {\n// buggy lines end\n        \n        throw new AbortException(\"Waiting for non-job items is not supported\");\n    }\n    if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n        final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n        listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n        node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n        List<Action> actions = new ArrayList<>();\n        if (step.getWait()) {\n            StepContext context = getContext();\n            actions.add(new BuildTriggerAction(context, step.isPropagate()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n        }\n        actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n        List<ParameterValue> parameters = step.getParameters();\n        if (parameters != null) {\n            parameters = completeDefaultParameters(parameters, (Job) project);\n            actions.add(new ParametersAction(parameters));\n        }\n        Integer quietPeriod = step.getQuietPeriod();\n        if (quietPeriod == null) {\n            quietPeriod = project.getQuietPeriod();\n        }\n        QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n            @Override\n            protected Job asJob() {\n                return (Job) project;\n            }\n        }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n        if (f == null) {\n            throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n        }\n    } else if (item instanceof Queue.Task){\n        if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n            throw new AbortException(\"Item type does not support parameters\");\n        }\n        Queue.Task task = (Queue.Task) item;\n        listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n        node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n        List<Action> actions = new ArrayList<>();\n        if (step.getWait()) {\n            StepContext context = getContext();\n            actions.add(new BuildTriggerAction(context, step.isPropagate()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n        }\n        actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n        Integer quietPeriod = step.getQuietPeriod();\n        if (quietPeriod == null) {\n            try {\n                Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                if (getQuietPeriod.getReturnType().equals(int.class)) {\n                    quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                }\n            } catch (NoSuchMethodException e) {\n            } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n            }\n        }\n        if (quietPeriod == null) {\n            quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n        }\n        ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n        if (scheduleResult.isRefused()) {\n            throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n        }\n    } else {\n        throw new AbortException(\"The item named \" + job + \" is a \"\n                + (item instanceof Describable\n                ? ((Describable) item).getDescriptor().getDisplayName()\n                : item.getClass().getName())\n                + \" which is not something that can be built\");\n    }\n    if (step.getWait()) {\n        return false;\n    } else {\n        getContext().onSuccess(null);\n        return true;\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-59": {
      "loc": "27-27",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            break;\n        case '\"':\n            t.transition(AttributeValue_doubleQuoted);\n            break;\n        case '&':\n            r.unconsume();\n            t.transition(AttributeValue_unquoted);\n            break;\n        case '\\'':\n            t.transition(AttributeValue_singleQuoted);\n            break;\n        case nullChar:\n            t.error(this);\n            t.tagPending.appendAttributeValue(replacementChar);\n            t.transition(AttributeValue_unquoted);\n            break;\n        case eof:\n            t.eofError(this);\n// buggy lines start:\n            t.transition(Data);\n// buggy lines end\n            break;\n        case '>':\n            t.error(this);\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '<':\n        case '=':\n        case '`':\n            t.error(this);\n            t.tagPending.appendAttributeValue(c);\n            t.transition(AttributeValue_unquoted);\n            break;\n        default:\n            r.unconsume();\n            t.transition(AttributeValue_unquoted);\n    }\n}\n// fixed lines:\n"
    },
    "VUL4J-61": {
      "loc": "9-9",
      "input": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    if (config == null) config = Collections.emptyMap();\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n// buggy lines start:\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n// buggy lines end\n\n        FileUtils.checkReadAllowed(url);\n        Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n        Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        XPath xPath = xPathFactory.newXPath();\n        path = StringUtils.isEmpty(path) ? \"/\" : path;\n        XPathExpression xPathExpression = xPath.compile(path);\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            handleNode(stack, nodeList.item(i), simpleMode);\n            for (int index = 0; index < stack.size(); index++) {\n                result.add(new MapResult(stack.pollFirst()));\n            }\n        }\n    }\n    catch (FileNotFoundException e){\n        if(!failOnError)\n            return Stream.of(new MapResult(Collections.emptyMap()));\n        else\n            throw new FileNotFoundException(e.getMessage());\n    }\n    catch (Exception e){\n        if(!failOnError)\n            return Stream.of(new MapResult(Collections.emptyMap()));\n        else\n            throw new Exception(e);\n    }\n    return result.stream();\n}\n// fixed lines:\n"
    },
    "VUL4J-64": {
      "loc": "5-5",
      "input": "final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n    factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n// buggy lines start:\n    return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n// buggy lines end\n}\n// fixed lines:\n"
    },
    "VUL4J-65": {
      "loc": "7-7",
      "input": "static public File allocateFile(File dir, String name) {\n    int q = name.indexOf('?');\n    if (q > 0) {\n        name = name.substring(0, q);\n    }\n    File file = new File(dir, name);\n// buggy lines start:\n    int dot = name.indexOf('.');\n// buggy lines end\n    String prefix = dot < 0 ? name : name.substring(0, dot);\n    String suffix = dot < 0 ? \"\" : name.substring(dot);\n    int index = 2;\n    while (file.exists()) {\n        file = new File(dir, prefix + \"-\" + index++ + suffix);\n    }\n    file.getParentFile().mkdirs();\n    return file;\n}\n// fixed lines:\n"
    },
    "VUL4J-66": {
      "loc": "21-21",
      "input": "protected static boolean isValid(String str)\n{\n   if (str == null || str.length() == 0) return false;\n   for (int i = 0; i < str.length(); i++) {\n      switch (str.charAt(i))\n      {\n         case '/':\n         case '\\\\':\n         case '?':\n         case ':':\n         case '<':\n         case '>':\n         case ';':\n         case '(':\n         case ')':\n         case '@':\n         case ',':\n         case '[':\n         case ']':\n         case '=':\n// buggy lines start:\n            return false;\n// buggy lines end\n         default:\n            break;\n      }\n   }\n   return true;\n}\n// fixed lines:\n"
    },
    "VUL4J-73": {
      "loc": "2-2",
      "input": "public boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n// buggy lines start:\n\tString pass1 = encPass + \"\";\n// buggy lines end\n\n\tString pass2 = mergePasswordAndSalt(rawPass, salt, false);\n\tif (ignorePasswordCase) {\n\t\tpass1 = pass1.toLowerCase(Locale.ENGLISH);\n\t\tpass2 = pass2.toLowerCase(Locale.ENGLISH);\n\t}\n\treturn PasswordEncoderUtils.equals(pass1, pass2);\n}\n// fixed lines:\n"
    },
    "VUL4J-74": {
      "loc": "3-9",
      "input": "public SecureRandom getObject() throws Exception {\n\tSecureRandom rnd = SecureRandom.getInstance(algorithm);\n// buggy lines start:\n\tif (seed != null) {\n\t\tbyte[] seedBytes = FileCopyUtils.copyToByteArray(seed.getInputStream());\n\t\trnd.setSeed(seedBytes);\n\t}\n\telse {\n\t\trnd.nextBytes(new byte[1]);\n\t}\n// buggy lines end\n\n\treturn rnd;\n}\n// fixed lines:\n"
    }
  }
}