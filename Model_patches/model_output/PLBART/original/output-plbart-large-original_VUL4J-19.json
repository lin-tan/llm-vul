{
    "function range": "2,1-95,1",
    "output": [
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (isEmpty(encryption.getMethod()); } else { if (isEmpty(encryption.getMethod()); } else",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (typeof(Dictionary) == null ||! validateDictionary() ) { throw new IllegalArgumentException(); } if (",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength); } else { if (isEmpty(encryption.getMethod()); } else { if (isEmpty(encryption.getMethod()); } else",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (typeof(Dictionary) == null ||! validateDictionary() ) { throw new IllegalArgumentException(); } } if",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (isEmpty(encryption.getMethod()); } else { if (isEmpty(encryption.getMethod()) { }",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (typeof(Dictionary) == null ||! validateDictionary() ) { throw new IOException(\"\"); } } if",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (isEmpty(encryption.getMethod()); } else { if (typeof(Dictionary) == null) { }",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength); } else { if (isEmpty(encryption.getMethod()); } else { if (isEmpty(encryption.getMethod()) { }",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (typeof(Dictionary) == null ||! validateDictionary() ) { throw new IOException(\"\"); } if (",
        "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); } else { if (isEmpty(encryption.getMethod()); } else { if (isEmpty(encryption.getMethod()); } if"
    ],
    "validation_result": [
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); boolean encryptMetadata = encryption.isEncryptMetaData(); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = AccessPermission.getOwnerAccessPermission(); setCurrentAccessPermission(currentAccessPermission); byte[] computedPassword; if (dicRevision == 6 || dicRevision == 5) { computedPassword = password.getBytes(passwordCharset); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset); } encryptionKey = computeEncryptedKey( computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata); } else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata) ) { currentAccessPermission = new AccessPermission(dicPermissions); } encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), password, ownerKey, userKey, ue, dicPermissions, documentIDBytes, dicRevision, dicLength ); }",
            "correctness": "uncompilable"
        }
    ]
}