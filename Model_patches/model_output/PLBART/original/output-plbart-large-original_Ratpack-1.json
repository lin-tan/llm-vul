{
    "function range": "2,1-84,1",
    "output": [
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); requestConstants.response = response; } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } else { } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } else { handler = null; } }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } else { return; } responseBody = null; }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } else { } responseBody = null; } }",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; } else { handler = null; } responseBody = null; } else { } responseBody = null; } else { }"
    ],
    "validation_result": [
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); requestConstants.response = response; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception { if (!nettyRequest.decoderResult().isSuccess()) { LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause()); sendError(ctx, HttpResponseStatus.BAD_REQUEST); return; } Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers()); Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING); boolean hasBody = (contentLength > 0) || (transferEncoding!= null); RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null; Channel channel = ctx.channel(); if (requestBody!= null) { channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody); } InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress(); InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress(); ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel); DefaultRequest request = new DefaultRequest( clock.instant(), requestHeaders, nettyRequest.method(), nettyRequest.protocolVersion(), nettyRequest.uri(), remoteAddress, socketAddress, serverRegistry.get(ServerConfig.class), requestBody, connectionIdleTimeout, channel.attr(CLIENT_CERT_KEY).get() ); MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders); AtomicBoolean transmitted = new AtomicBoolean(false); DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody); ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter); Action<Action<Object>> subscribeHandler = thing -> { transmitted.set(true); ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing); }; DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants( applicationConstants, request, channel, responseTransmitter, subscribeHandler ); Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter); handler = null; }",
            "correctness": "uncompilable"
        }
    ]
}