{
    "function range": "2,5-73,5",
    "output": [
        "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
        "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }"
    ],
    "validation_result": [
        {
            "patch": "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        },
        {
            "patch": "protected void takeOutDataFile( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); try { if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } if ( whetherOverwrite() ||!targetFile.exists() || targetFile.lastModified() < itemTime.getTime() ) { final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if ( StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { if (! whetherFolder ) { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } else { targetFile.mkdirs(); } } else{ File symlinkDestFile = new File( symbolicLinkTargetLocation ); SymlinkUtils.createSymbolicLink( targetFile, symlinkDestFile); } long time = itemTime.getTime(); targetFile.setLastModified( time ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } }else{ return; } } catch ( final FileNotFoundException e ) { String path = targetFile.getPath(); acquireLogger().warn( \"Unable to expand to file \" + path ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); try { if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } if ( isOverwrite() ||!f.exists() || f.lastModified() < entryDate.getTime() ) { final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if ( StringUtils.isEmpty( symlinkDestination ) ) { if (! isDirectory ) { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } else { f.mkdirs(); } } else{ File symlinkDestFile = new File( symlinkDestination ); SymlinkUtils.createSymbolicLink( f, symlinkDestFile); } long time = entryDate.getTime(); f.setLastModified( time ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } }else{ return; } } catch ( final FileNotFoundException ex ) { String path = f.getPath(); getLogger().warn( \"Unable to expand to file \" + path ); } }"
        }
    ]
}