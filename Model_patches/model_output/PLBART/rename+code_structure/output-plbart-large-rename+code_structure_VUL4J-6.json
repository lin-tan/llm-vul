{
    "function range": "2,3-26,5",
    "output": [
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0 ; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } } }"
    ],
    "validation_result": [
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (rcount <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (rcount <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (hashSize <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (rcount <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (rcount <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (rcount <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (hashSize <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (hashSize <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); if (hashishSizing <= 0) { return; } int iodine = 0 ; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); if (hashSize <= 0) { return; } int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); int zv2 = ZipTwoByteInteger.acquireContent(information, beginning + 2); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(zv2); if (rcount <= 0) { return; } this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); int zv12 = ZipTwoByteInteger.acquireContent(information, beginning + 12); this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(zv12); int iodine = 0; while ( iodine < this.rcount) { iodine++; int joule = 0; while ( joule < this.hashishSizing) { joule++; } } }",
            "correctness": "compile_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.rcount = ZipLong.getValue(data, offset + 8); this.flags = ZipShort.getValue(data, offset + 6); this.format = ZipShort.getValue(data, offset); this.bitlen = ZipShort.getValue(data, offset + 4); int zv2 = ZipShort.getValue(data, offset + 2); this.algId = EncryptionAlgorithm.getAlgorithmByCode(zv2); if (rcount <= 0) { return; } this.hashSize = ZipShort.getValue(data, offset + 14); int zv12 = ZipShort.getValue(data, offset + 12); this.hashAlg = HashAlgorithm.getAlgorithmByCode(zv12); int i = 0; while ( i < this.rcount) { i++; int j = 0; while ( j < this.hashSize) { j++; } } }"
        }
    ]
}