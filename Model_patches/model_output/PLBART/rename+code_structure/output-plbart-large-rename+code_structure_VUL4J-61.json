{
    "function range": "2,5-61,5",
    "output": [
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream, \"UTF-8\"))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); } }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream, \"UTF-8\"))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome; }",
        "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); } }"
    ],
    "validation_result": [
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result.stream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result.stream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result.stream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream, \"UTF-8\"))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream, \"UTF-8\"))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return outcomestream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder(); Document doc = builder.parse(inputStream); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result.stream(); }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream, \"UTF-8\"))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome; }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream, \"UTF-8\"))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result; }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception { setting = setting == null? Collections.emptyMap():setting; boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true); List<MapOutcome> outcome = new ArrayList<>(); try { FileUtils.examineReadPermitted(URL); DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); archiveCreatorFactory.setIgnoringElementContentWhitespace(true); archiveCreatorFactory.setNamespaceAware(true); if(StringUtils.isEmpty(way) ){ way = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(way); InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = archiveCreatorFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream))); NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int m = 0; while ( m < vertexListing.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_m = vertexListing.item(m); manageNode(stack, node_m, easyManner); int position = 0; while ( position < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); outcome.add(new MapOutcome(stack_first)); position++; } m++; } } catch (FileNotFoundException x){ if(breakDownAlongMistake){ String message = x.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } catch (Exception x){ if(breakDownAlongMistake){ throw new Exception(x); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapOutcome mapResult = new MapOutcome(emptyMap); return Stream.of(mapResult); } } return outcome.stream(); }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception { config = config == null? Collections.emptyMap():config; boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true); List<MapResult> result = new ArrayList<>(); try { FileUtils.checkReadAllowed(url); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); XPathFactory xPathFactory = XPathFactory.newInstance(); documentBuilderFactory.setIgnoringElementContentWhitespace(true); documentBuilderFactory.setNamespaceAware(true); if(StringUtils.isEmpty(path) ){ path = \"/\" ; } XPathExpression xPathExpression = xPathFactory.newXPath().compile(path); InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null); Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new InputStreamReader( inputStream))); NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET); int i = 0; while ( i < nodeList.getLength()) { final Deque<Map<String, Object>> stack = new LinkedList<>(); Node node_i = nodeList.item(i); handleNode(stack, node_i, simpleMode); int index = 0; while ( index < stack.size()) { Map<String, Object> stack_first = stack.pollFirst(); result.add(new MapResult(stack_first)); index++; } i++; } } catch (FileNotFoundException e){ if(failOnError){ String message = e.getMessage(); throw new FileNotFoundException(message); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } catch (Exception e){ if(failOnError){ throw new Exception(e); }else{ Map<String, Object> emptyMap =Collections.emptyMap(); MapResult mapResult = new MapResult(emptyMap); return Stream.of(mapResult); } } return result.stream(); }"
        }
    ]
}