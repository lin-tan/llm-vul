{
    "function range": "2,1-35,1",
    "output": [
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = CharBuffer.wrap(charBuffer.get()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
        "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result ; }"
    ],
    "validation_result": [
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isUnderflow()) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } out = ZipEncodingHelper.growBufferBy(out, increment - out.remaining()); } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); i++) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } out = ZipEncodingHelper.growBufferBy(out, increment - out.remaining()); } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } result = CompressedFileEncodingAssistant.enlargeBufferWith(result, increase - result.remaining()); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } out = ZipEncodingHelper.growBufferBy(out, increment - out.remaining()); } else { tmp = null; } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isUnderflow()) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); tmp = null; } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isUnderflow()) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } else { tmp = null; } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = CharBuffer.wrap(charBuffer.get()); } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result; }",
            "correctness": "uncompilable",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isUnderflow()) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } else { tmp = CharBuffer.wrap(cb.get()); } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        },
        {
            "patch": "@Override public ByteBuffer encode(final String tile) { final CharsetEncoder charEncoder = newEncoder(); final CharBuffer charBuffer = CharBuffer.wrap(tile); CharBuffer cb_temp = null; ByteBuffer result = ByteBuffer.allocate(approximateOriginalBufferSize(charEncoder, charBuffer.remaining())); while (charBuffer.remaining() > 0) { final CoderResult outcome = charEncoder.encode(charBuffer, result, false); if (outcome.isUnmappable() || outcome.isMalformed()) { int roomForSubstitute = approximateAdditionalEncodeingSize(charEncoder, 6 * outcome.length()); if (roomForSubstitute > result.remaining()) { int charAmount = 0; for (int j = charBuffer.position() ; j < charBuffer.limit(); j++) { charAmount +=!charEncoder.ableToEncode(charBuffer.get(j))? 6 : 1; } int sumSupernumeraryInfinite = approximateAdditionalEncodeingSize(charEncoder, charAmount); result = CompressedFileEncodingAssistant.enlargeBufferWith(result, sumSupernumeraryInfinite - result.remaining()); } if (cb_temp == null) { cb_temp = CharBuffer.allocate(6); } for (int j = 0; j < outcome.length(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isOverflow()) { int increase = approximateAdditionalEncodeingSize(charEncoder, charBuffer.remaining()); for (int j = charBuffer.position() ; j < charBuffer.limit(); ++j) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } } else if (outcome.isUnderflow()) { result = encodeEntirely(charEncoder, encodeSubstitute(cb_temp, charBuffer.get()), result); } else { cb_temp = null; } } charEncoder.encode(charBuffer, result, true); result.limit(result.position()); result.rewind(); return result ; }",
            "correctness": "compile_success",
            "translated": "@Override public ByteBuffer encode(final String name) { final CharsetEncoder enc = newEncoder(); final CharBuffer cb = CharBuffer.wrap(name); CharBuffer tmp = null; ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining())); while (cb.remaining() > 0) { final CoderResult res = enc.encode(cb, out, false); if (res.isUnmappable() || res.isMalformed()) { int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length()); if (spaceForSurrogate > out.remaining()) { int charCount = 0; for (int i = cb.position() ; i < cb.limit(); i++) { charCount +=!enc.canEncode(cb.get(i))? 6 : 1; } int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount); out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining()); } if (tmp == null) { tmp = CharBuffer.allocate(6); } for (int i = 0; i < res.length(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isOverflow()) { int increment = estimateIncrementalEncodingSize(enc, cb.remaining()); for (int i = cb.position() ; i < cb.limit(); ++i) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } } else if (res.isUnderflow()) { out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out); } else { tmp = null; } } enc.encode(cb, out, true); out.limit(out.position()); out.rewind(); return out; }"
        }
    ]
}