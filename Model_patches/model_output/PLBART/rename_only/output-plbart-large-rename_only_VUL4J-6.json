{
    "function range": "2,1-16,1",
    "output": [
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashish!= null && this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashish!= null && this.hashishSizing > 0 ) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
        "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }"
    ],
    "validation_result": [
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (this.hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (this.hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (this.hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashish!= null && this.hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (this.hashAlg!= null && this.hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (this.hashish!= null && this.hashishSizing > 0 ) { for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte [ ] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (this.hashAlg!= null && this.hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte[] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } for (int j = 0; j < this.hashSize; j++) { } } } }"
        },
        {
            "patch": "public void analyzeCentralDirectoryScheme (final byte [ ] information, final int beginning, final int duration) { this.formatting = ZipTwoByteInteger.acquireContent(information, beginning); this.Idaho = EncodingAlgorithm.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 2)); this.bitlen = ZipTwoByteInteger.acquireContent(information, beginning + 4); this.flag = ZipTwoByteInteger.acquireContent(information, beginning + 6); this.rcount = ZipFourByteInteger.acquireContent(information, beginning + 8); if (rcount > 0) { this.hashish = AlgorithmForHash.acquireAlgorithmThroughCode(ZipTwoByteInteger.acquireContent(information, beginning + 12)); this.hashishSizing = ZipTwoByteInteger.acquireContent(information, beginning + 14); if (hashishSizing > 0) { for (int joule = 0; joule < this.hashishSizing; joule++) { } for (int joule = 0; joule < this.hashishSizing; joule++) { } } } }",
            "correctness": "test_success",
            "translated": "public void parseCentralDirectoryFormat (final byte[] data, final int offset, final int length) { this.format = ZipShort.getValue(data, offset); this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2)); this.bitlen = ZipShort.getValue(data, offset + 4); this.flags = ZipShort.getValue(data, offset + 6); this.rcount = ZipLong.getValue(data, offset + 8); if (rcount > 0) { this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12)); this.hashSize = ZipShort.getValue(data, offset + 14); if (hashSize > 0) { for (int j = 0; j < this.hashSize; j++) { } for (int j = 0; j < this.hashSize; j++) { } } } }"
        }
    ]
}