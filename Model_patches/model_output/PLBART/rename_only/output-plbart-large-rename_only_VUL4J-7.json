{
    "function range": "2,1-30,1",
    "output": [
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } if (present.byteRetrievedFromDataSequence + x > size) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; } }",
        "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; } }",
        "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; } }"
    ],
    "validation_result": [
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } if (present.byteRetrievedFromDataSequence + x > size) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } if (current.bytesReadFromStream + l > csize) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte[] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        },
        {
            "patch": "private int retrieveSaved(final byte [ ] byteArrary, final int distance, final int range) throws IOException { if (present.withInformationForm) { if (finalSavedItem == null) { retrieveSavedItem(); } return finalSavedItem.read(byteArrary, distance, range); } final long size = present.item.acquireSize(); if (present.byteRetrieved >= size) { return -1; } if (memory.position() >= memory.limit()) { memory.position(0); final int x = input.read(memory.array()); if (x == -1) { throw new EOFException(); } memory.limit(x); calculate(x); present.byteRetrievedFromDataSequence += x; } int toRetrieve = Math.min(memory.remaining(), range); if ((size - present.byteRetrieved) < toRetrieve) { toRetrieve = (int) (size - present.byteRetrieved); } memory.get(byteArrary, distance, toRetrieve); present.byteRetrieved += toRetrieve; return toRetrieve; }",
            "correctness": "compile_success",
            "translated": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException { if (current.hasDataDescriptor) { if (lastStoredEntry == null) { readStoredEntry(); } return lastStoredEntry.read(buffer, offset, length); } final long csize = current.entry.getSize(); if (current.bytesRead >= csize) { return -1; } if (buf.position() >= buf.limit()) { buf.position(0); final int l = in.read(buf.array()); if (l == -1) { throw new EOFException(); } buf.limit(l); count(l); current.bytesReadFromStream += l; } int toRead = Math.min(buf.remaining(), length); if ((csize - current.bytesRead) < toRead) { toRead = (int) (csize - current.bytesRead); } buf.get(buffer, offset, toRead); current.bytesRead += toRead; return toRead; }"
        }
    ]
}