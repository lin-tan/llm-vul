{
    "function range": "2,1-95,1",
    "output": [
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet));) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } } ); }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet));) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } } ); }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } } }); }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } else { } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } else { } } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } } else { } }",
        "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } } else { } } ); }"
    ],
    "validation_result": [
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet));) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset));) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet));) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset));) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        },
        {
            "patch": "@Override public void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray, DecodingInformation decipherInformation) throws IOException { if(!(decipherInformation instanceof CriterionDecodingInformation)) { throw new IOException(\"Decryption material is not compatible with the document\"); } adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData()); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; String watchword = information.acquireWatchword(); if(watchword == null) { watchword = \"\"; } int lexiconConsent = cipher.acquireConsent(); int lexiconAlteration = cipher.acquireAlteration(); int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8; byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray); CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation; byte[] cipherDescriptiveData = cipher.beCipherDescriptiveData(); byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier(); byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier(); byte[] ec = null, pc = null; Charset watchwordCharSet = Charsets.ISO_8859_1; if (lexiconAlteration == 6 || lexiconAlteration == 5) { watchwordCharSet = Charsets.UTF_8; ec = cipher.acquireExploiterEncodingUniqueIdentifier(); pc = cipher.acquireProprietorCipherUniqueIdentifier(); } UseConsent presentUseConsent; if( beProprietorWatchword(watchword.getBytes(watchwordCharSet),)) { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } else { calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet)); } if( true) { } else { } }",
            "correctness": "uncompilable",
            "translated": "@Override public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException { if(!(decryptionMaterial instanceof StandardDecryptionMaterial)) { throw new IOException(\"Decryption material is not compatible with the document\"); } setDecryptMetadata(encryption.isEncryptMetaData()); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; String password = material.getPassword(); if(password == null) { password = \"\"; } int dicPermissions = encryption.getPermissions(); int dicRevision = encryption.getRevision(); int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8; byte[] documentIDBytes = getDocumentIDBytes(documentIDArray); StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial; byte[] encryptMetadata = encryption.isEncryptMetaData(); byte[] userKey = encryption.getUserKey(); byte[] ownerKey = encryption.getOwnerKey(); byte[] ue = null, oe = null; Charset passwordCharset = Charsets.ISO_8859_1; if (dicRevision == 6 || dicRevision == 5) { passwordCharset = Charsets.UTF_8; ue = encryption.getUserEncryptionKey(); oe = encryption.getOwnerEncryptionKey(); } AccessPermission currentAccessPermission; if( isOwnerPassword(password.getBytes(passwordCharset),)) { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } else { computedPassword = getUserPassword(password.getBytes(passwordCharset)); } if( true) { } else { } }"
        }
    ]
}