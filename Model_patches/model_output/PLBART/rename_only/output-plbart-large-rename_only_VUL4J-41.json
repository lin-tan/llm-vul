{
    "function range": "2,1-52,1",
    "output": [
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { throw new DocumentorException ( \"Unable to expand to file \" + itemTitle ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + itemTitle ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + itemTitle ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
        "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { throw new DocumentorException ( \"Unable to expand to file \" + itemTitle ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }"
    ],
    "validation_result": [
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { throw new DocumentorException ( \"Unable to expand to file \" + itemTitle ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { throw new ArchiverException ( \"Unable to expand to file \" + entryName ); } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); return; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); return; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); return; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); return; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + itemTitle ); return ; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + entryName ); return ; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { acquireLogger().warn( \"Unable to expand to file \" + itemTitle ); return; } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { getLogger().warn( \"Unable to expand to file \" + entryName ); return ; } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        },
        {
            "patch": "protected void takeOutDataFile ( final File originFile, final File folder, final InputStream compressedInDataSequence, final String itemTitle, final Date itemTime, final boolean whetherFolder, final Integer setting, String symbolicLinkTargetLocation ) throws IOException, DocumentorException { final File targetFile = FileUtils.resolveFile( folder, itemTitle ); if ( targetFile == null ) { throw new DocumentorException ( \"Unable to expand to file \" + itemTitle ); } try { if (!whetherOverwrite() && targetFile.exists() && ( targetFile.lastModified() >= itemTime.getTime() ) ) { return; } final File parentFile = targetFile.getParentFile(); if ( parentFile!= null ) { parentFile.mkdirs(); } if (!StringUtils.isEmpty( symbolicLinkTargetLocation ) ) { SymlinkUtils.createSymbolicLink( targetFile, new File( symbolicLinkTargetLocation ) ); } else if ( whetherFolder ) { targetFile.mkdirs(); } else { OutputStream output = null; try { output = new FileOutputStream( targetFile ); IOUtil.copy( compressedInDataSequence, output ); output.close(); output = null; } finally { IOUtil.close( output ); } } targetFile.setLastModified( itemTime.getTime() ); if (!whetherDisregardConsent() && setting!= null &&!whetherFolder ) { DocumentItemUtility.changeMode( targetFile, setting ); } } catch ( final FileNotFoundException e ) { acquireLogger().warn( \"Unable to expand to file \" + targetFile.getPath() ); } }",
            "correctness": "compile_success",
            "translated": "protected void extractFile ( final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination ) throws IOException, ArchiverException { final File f = FileUtils.resolveFile( dir, entryName ); if ( f == null ) { throw new ArchiverException ( \"Unable to expand to file \" + entryName ); } try { if (!isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) ) { return; } final File dirF = f.getParentFile(); if ( dirF!= null ) { dirF.mkdirs(); } if (!StringUtils.isEmpty( symlinkDestination ) ) { SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) ); } else if ( isDirectory ) { f.mkdirs(); } else { OutputStream out = null; try { out = new FileOutputStream( f ); IOUtil.copy( compressedInputStream, out ); out.close(); out = null; } finally { IOUtil.close( out ); } } f.setLastModified( entryDate.getTime() ); if (!isIgnorePermissions() && mode!= null &&!isDirectory ) { ArchiveEntryUtils.chmod( f, mode ); } } catch ( final FileNotFoundException ex ) { getLogger().warn( \"Unable to expand to file \" + f.getPath() ); } }"
        }
    ]
}