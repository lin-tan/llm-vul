{
    "output": [
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    throw new EOFException();\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    throw new IOException(\"String_Node_Str\");\n<|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    break;\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    throw new EOFException(\"String_Node_Str\");\n<|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    return -1 - offset;\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    throw new IOException();\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    return -1 - buf.remaining();\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    buf.limit(0);\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    buf.limit(buf.limit());\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (!current.hasDataDescriptor) {\n        final long csize = current.entry.getSize();\n        if (current.bytesRead < csize) {\n            if (buf.position() >= buf.limit()) {\n                buf.position(0);\n                byte[] bufArray = buf.array();\n                final int l = in.read(bufArray);\n                if (l!= -1) {\n                    buf.limit(l);\n                    count(l);\n                    current.bytesReadFromStream += l;\n                }else{\n// buggy lines start:\n                    return -1;\n// buggy lines end\n                }\n            }\n            int bufRemaining = buf.remaining();\n            int toRead = Math.min(bufRemaining, length);\n            if ((csize - current.bytesRead) < toRead) {\n                toRead = (int) (csize - current.bytesRead);\n            }\n            buf.get(buffer, offset, toRead);\n            current.bytesRead += toRead;\n            return toRead;\n        }else{\n            return -1;\n        }\n    }else{\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n}\n// fixed lines:\n                    throw new EOFException(csize);\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    ],
    "validation_result": [
        {
            "patch": "                    throw new EOFException();\n",
            "correctness": "compile_success",
            "translated": "                    throw new EOFException();\n"
        },
        {
            "patch": "                    throw new IOException(\"String_Node_Str\");\n",
            "correctness": "compile_success",
            "translated": "                    throw new IOException(\"String_Node_Str\");\n"
        },
        {
            "patch": "                    break;\n",
            "correctness": "uncompilable",
            "translated": "                    break;\n"
        },
        {
            "patch": "                    throw new EOFException(\"String_Node_Str\");\n",
            "correctness": "compile_success",
            "translated": "                    throw new EOFException(\"String_Node_Str\");\n"
        },
        {
            "patch": "                    return -1 - offset;\n",
            "correctness": "compile_success",
            "translated": "                    return -1 - offset;\n"
        },
        {
            "patch": "                    throw new IOException();\n",
            "correctness": "compile_success",
            "translated": "                    throw new IOException();\n"
        },
        {
            "patch": "                    return -1 - buf.remaining();\n",
            "correctness": "compile_success",
            "translated": "                    return -1 - buf.remaining();\n"
        },
        {
            "patch": "                    buf.limit(0);\n",
            "correctness": "test_timeout",
            "translated": "                    buf.limit(0);\n"
        },
        {
            "patch": "                    buf.limit(buf.limit());\n",
            "correctness": "compile_success",
            "translated": "                    buf.limit(buf.limit());\n"
        },
        {
            "patch": "                    throw new EOFException(csize);\n",
            "correctness": "uncompilable",
            "translated": "                    throw new EOFException(csize);\n"
        }
    ]
}