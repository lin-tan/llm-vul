{
    "output": [
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    accessPermission = new AccessPermission(dicPermissions);\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.getCurrentAccessPermission());\n<|endoftext|><|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    currentAccessPermission = new AccessPermission(dicPermissions);\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.getInstance(dicPermissions));\n<|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setAccessPermission(new AccessPermission(dicPermissions));\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    permission = new AccessPermission(dicPermissions);\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions, true));\n<|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    AccessPermission accessPermission = new AccessPermission(dicPermissions);\n<|endoftext|><|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions, false));\n<|endoftext|>",
        "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        if(!isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    byte[] passwordByteArray = password.getBytes(passwordCharset);\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                byte[] passwordByteArray = password.getBytes(passwordCharset);\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    ],
    "validation_result": [
        {
            "patch": "                    accessPermission = new AccessPermission(dicPermissions);\n",
            "correctness": "uncompilable",
            "translated": "                    accessPermission = new AccessPermission(dicPermissions);\n"
        },
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.getCurrentAccessPermission());\n",
            "correctness": "uncompilable",
            "translated": "                    setCurrentAccessPermission(AccessPermission.getCurrentAccessPermission());\n"
        },
        {
            "patch": "                    currentAccessPermission = new AccessPermission(dicPermissions);\n",
            "correctness": "uncompilable",
            "translated": "                    currentAccessPermission = new AccessPermission(dicPermissions);\n"
        },
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.getInstance(dicPermissions));\n",
            "correctness": "uncompilable",
            "translated": "                    setCurrentAccessPermission(AccessPermission.getInstance(dicPermissions));\n"
        },
        {
            "patch": "                    setAccessPermission(new AccessPermission(dicPermissions));\n",
            "correctness": "uncompilable",
            "translated": "                    setAccessPermission(new AccessPermission(dicPermissions));\n"
        },
        {
            "patch": "                    permission = new AccessPermission(dicPermissions);\n",
            "correctness": "uncompilable",
            "translated": "                    permission = new AccessPermission(dicPermissions);\n"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, true));\n",
            "correctness": "uncompilable",
            "translated": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, true));\n"
        },
        {
            "patch": "                    AccessPermission accessPermission = new AccessPermission(dicPermissions);\n",
            "correctness": "compile_success",
            "translated": "                    AccessPermission accessPermission = new AccessPermission(dicPermissions);\n"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, false));\n",
            "correctness": "uncompilable",
            "translated": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, false));\n"
        },
        {
            "patch": "",
            "correctness": "compile_success",
            "translated": ""
        }
    ]
}