{
    "output": [
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer in) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(in.remaining());\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(buffer.remaining());\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer in) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(in.remaining());\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (offset < length) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer in) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(in.remaining());\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (length > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(buffer.remaining());\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0 && cb.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0 && cb.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer in) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(in.remaining());\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0 && cb.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0 && cb.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer in) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(in.remaining());\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (in.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer in, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.wrap(in.array(), offset, length);\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = dec.decode(in, cb, false);\n           if (!res.isUnmappable() &&!res.",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(buffer.remaining());\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, offset, length, cb, false);\n           if (!res.isUnmappable() &&!res.is",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(buffer.remaining());\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (length > 0) {\n           final CoderResult res = dec.decode(buffer, offset, length, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {",
        "   @Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(buffer.remaining());\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.allocate(length);\n       \n       while (buffer.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   cb = ZipEncodingHelper.growBufferBy(cb, estimateIncrementalDecodingSize(dec, cbr));\n               }\n               break;\n           }\n       }\n       cb.flip();\n       return cb.toString();\n   }\n\n   @Override\n   public String decode(final ByteBuffer buffer, final int offset, final int length) {\n       final CharsetDecoder dec = newDecoder();\n       final CharBuffer cb = CharBuffer.wrap(buffer.array(), offset, length);\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = dec.decode(buffer, cb, false);\n           if (!res.isUnmappable() &&!res."
    ],
    "validation_result": [
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "@Override\n   public ByteBuffer encode(final String name) {\n       final CharBuffer cb = CharBuffer.wrap(name);\n       \n       int initial_cbr = cb.remaining();\n       final CharsetEncoder enc = newEncoder();\n       int size = estimateInitialBufferSize(enc, initial_cbr);\n       ByteBuffer out = ByteBuffer.allocate(size);\n       CharBuffer tmp = null;\n       \n       while (cb.remaining() > 0) {\n           final CoderResult res = enc.encode(cb, out, false);\n          if (!res.isUnmappable() &&!res.isMalformed()) {\n               if (res.isOverflow()) {\n                   int cbr = cb.remaining();\n                   out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n               }\n               break;\n          }\n       }\n       out.flip();\n       return out;\n   }",
            "correctness": "test_timeout"
        }
    ]
}