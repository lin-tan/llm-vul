{
    "output": [
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireWatchwordUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireWatchwordUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherDescriptiveData(cipherDescriptiveData);\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n    cipher.setWatchword(watchword);\n}\n}\n",
        "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherDescriptiveData(cipherDescriptiveData);\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setProprietorUniqueIdentifier(proprietorUniqueIdentifier);\n    cipher.setExploiterUniqueIdentifier(exploiterUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}\n}\n"
    ],
    "validation_result": [
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireExploiterUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireUserUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireWatchwordUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireWatchwordUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireUserUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireExploiterUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireWatchwordUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireWatchwordUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireExploiterUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherDescriptiveData(cipherDescriptiveData);\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireUserUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherDescriptiveData(encryptMetadata);\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireExploiterUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n    cipher.setWatchword(watchword);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireExploiterUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n    encryption.setWatchword(password);\n}"
        },
        {
            "patch": "@Override\npublic void getReadyForDecipher(PalladiumEncoding cipher, COSArray fileIdentifierArray,\n                                 DecodingInformation decipherInformation)\n                                 throws IOException\n{\n    if(!(decipherInformation instanceof CriterionDecodingInformation))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    adjustDecipherDescriptiveData(cipher.beCipherDescriptiveData());\n    CriterionDecodingInformation information = (CriterionDecodingInformation)decipherInformation;\n    String watchword = information.acquireWatchword();\n    if(watchword == null)\n    {\n        watchword = \"\";\n    }\n    int lexiconConsent = cipher.acquireConsent();\n    int lexiconAlteration = cipher.acquireAlteration();\n    int lexiconSize = cipher.acquireEdition() == 1? 5 : cipher.acquireSize() / 8;\n    byte[] fileIdentifierByte = acquireFileIdentifierByte(fileIdentifierArray);\n    boolean cipherDescriptiveData = cipher.beCipherDescriptiveData();\n    byte[] exploiterUniqueIdentifier = cipher.acquireExploiterUniqueIdentifier();\n    byte[] proprietorUniqueIdentifier = cipher.acquireProprietorUniqueIdentifier();\n    byte[] ec = null, pc = null;\n    Charset watchwordCharSet = Charsets.ISO_8859_1;\n    if (lexiconAlteration == 6 || lexiconAlteration == 5)\n    {\n        watchwordCharSet = Charsets.UTF_8;\n        ec = cipher.acquireExploiterEncodingUniqueIdentifier();\n        pc = cipher.acquireProprietorCipherUniqueIdentifier();\n    }\n    UseConsent presentUseConsent;\n    if( beProprietorWatchword(watchword.getBytes(watchwordCharSet), exploiterUniqueIdentifier, proprietorUniqueIdentifier,\n                             lexiconConsent, fileIdentifierByte, lexiconAlteration,\n                             lexiconSize, cipherDescriptiveData) )\n    {\n        presentUseConsent = UseConsent.acquireProprietorUseConsen();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, true );\n    }\n    else\n    {\n        presentUseConsent = UseConsent.acquireUserUseConsent();\n        adjustPresentUseConsent(presentUseConsent);\n        byte[] calculateWatchword;\n        if (lexiconAlteration == 6 || lexiconAlteration == 5)\n        {\n            calculateWatchword = watchword.getBytes(watchwordCharSet);\n        }\n        else\n        {\n            calculateWatchword = acquireExploiterWatchword(watchword.getBytes(watchwordCharSet),\n                    proprietorUniqueIdentifier, lexiconAlteration, lexiconSize );\n        }\n        cipherUniqueIdentifier =\n            calculateCipheredUniqueIdentifier(\n                calculateWatchword,\n                proprietorUniqueIdentifier, exploiterUniqueIdentifier, pc, ec,\n                lexiconConsent,\n                fileIdentifierByte,\n                lexiconAlteration,\n                lexiconSize,\n                cipherDescriptiveData, false );\n    }\n    cipher.setCipherDescriptiveData(cipherDescriptiveData);\n    cipher.setCipherUniqueIdentifier(cipherUniqueIdentifier);\n    cipher.setProprietorUniqueIdentifier(proprietorUniqueIdentifier);\n    cipher.setExploiterUniqueIdentifier(exploiterUniqueIdentifier);\n    cipher.setPresentUseConsent(presentUseConsent);\n}",
            "correctness": "uncompilable",
            "translated": "@Override\npublic void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                             dicPermissions, documentIDBytes, dicRevision,\n                             dicLength, encryptMetadata) )\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, true );\n    }\n    else\n    {\n        currentAccessPermission = AccessPermission.acquireUserUseConsent();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                    ownerKey, dicRevision, dicLength );\n        }\n        encryptionKey =\n            computeEncryptedKey(\n                computedPassword,\n                ownerKey, userKey, oe, ue,\n                dicPermissions,\n                documentIDBytes,\n                dicRevision,\n                dicLength,\n                encryptMetadata, false );\n    }\n    encryption.setCipherDescriptiveData(encryptMetadata);\n    encryption.setCipherUniqueIdentifier(encryptionKey);\n    encryption.setProprietorUniqueIdentifier(ownerKey);\n    encryption.setExploiterUniqueIdentifier(userKey);\n    encryption.setPresentUseConsent(currentAccessPermission);\n}"
        }
    ]
}