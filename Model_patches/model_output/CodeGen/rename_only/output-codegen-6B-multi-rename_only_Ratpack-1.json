{
    "output": [
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultFullHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  );\n}\n\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(new DefaultFullHttpResponse(\n    HttpVersion.HTTP_1_1,\n    status,\n    Unpooled.EMPTY_BUFFER\n  )).addListener(ChannelFutureListener.CLOSE);\n}\n\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  ).addListener(ChannelFutureListener.CLOSE);\n}\n\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultFullHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  ).addListener(ChannelFutureListener.CLOSE);\n}\n\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(new DefaultFullHttpResponse(\n    HttpVersion.HTTP_1_1,\n    status,\n    Unpooled.EMPTY_BUFFER\n  )).addListener(ChannelFutureListener.CLOSE);\n}\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  ).addListener(ChannelFutureListener.CLOSE);\n}\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultFullHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  ).addListener(ChannelFutureListener.CLOSE);\n}\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultFullHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  );\n  context.close();\n}\n\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(new DefaultFullHttpResponse(\n    HttpVersion.HTTP_1_1,\n    status,\n    Unpooled.EMPTY_BUFFER\n  )).addListener(ChannelFutureListener.CLOSE);\n}\n",
        "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}\n\nprivate void directMistake(ChannelHandlerContext context, HttpResponseStatus status) {\n  context.writeAndFlush(\n    new DefaultHttpResponse(\n      HttpVersion.HTTP_1_1,\n      status,\n      Unpooled.EMPTY_BUFFER\n    )\n  ).addListener(ChannelFutureListener.CLOSE);\n}\n"
    ],
    "validation_result": [
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        },
        {
            "patch": "private void createQuery(ChannelHandlerContext context, HttpRequest httpQuery) throws Exception {\n  if (!httpQuery.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", httpQuery.decoderResult().cause());\n    directMistake(context, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headings queryHeading = new NetworkLibraryHeadingSupporteHeadings(httpQuery.headers());\n  Long messageSize = HttpUtil.getContentLength(httpQuery, -1L);\n  String transportationEncryption = queryHeading.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean withContent = (messageSize > 0) || (transportationEncryption!= null);\n  QueryContent queryContent = withContent? new QueryContent(messageSize, httpQuery, context) : null;\n  Channel channel = context.channel();\n  if (queryContent!= null) {\n    channel.attr(contentCollectorKey).set(queryContent);\n  }\n  InetSocketAddress distantReference = (InetSocketAddress) channel.distantReference();\n  InetSocketAddress reference = (InetSocketAddress) channel.localAddress();\n  ConnexionSpareTimeOver connexionTickOver = ConnexionSpareTimeOver.about(channel);\n  PrimaryQuery query = new PrimaryQuery(\n    time.instant(),\n    queryHeading,\n    httpQuery.method(),\n    httpQuery.protocolVersion(),\n    httpQuery.uri(),\n    distantReference,\n    reference,\n    hostRepository.get(ServerConfig.class),\n    queryContent,\n    connexionTickOver,\n    channel.attr(customerAutorizationKey).get()\n  );\n  context.fireChannelRead(query);\n}",
            "correctness": "test_timeout",
            "translated": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  ctx.fireChannelRead(request);\n}"
        }
    ]
}