{
    "output": [
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getAttribute(\"name\"));\n       mapOutcome.setUrl(element.getAttribute(\"url\"));\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getElementsByTagName(\"name\").item(0).getTextContent());\n       mapOutcome.setDescription(element.getElementsByTagName(\"description\").item(0).getTextContent());\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getElementsByTagName(\"name\").item(0).getTextContent());\n       mapOutcome.setDescription(element.getElementsByTagName(\"description\").item(0).getTextContent());\n       mapOutcome.setUrl(element.getElementsByTagName(\"url\").item(0).getTextContent());\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getAttribute(\"name\"));\n       mapOutcome.setType(element.getAttribute(\"type\"));\n       mapOutcome.setValue(element.getAttribute(\"value\"));\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getAttribute(\"name\"));\n       mapOutcome.setType(element.getAttribute(\"type\"));\n       mapOutcome.setUrl(element.getAttribute(\"url\"));\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getElementsByTagName(\"name\").item(0).getTextContent());\n       mapOutcome.setDescription(element.getElementsByTagName(\"description\").item(0).getTextContent());\n       return mapOutcome;\n   }\n\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getAttribute(\"name\"));\n       mapOutcome.setDescription(element.getAttribute(\"description\"));\n       mapOutcome.setUrl(element.getAttribute(\"url\"));\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getElementsByTagName(\"name\").item(0).getTextContent());\n       mapOutcome.setDescription(element.getElementsByTagName(\"description\").item(0).getTextContent());\n       return mapOutcome;\n   }\n   \n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getElementsByTagName(\"name\").item(0).getTextContent());\n       mapOutcome.setDescription(element.getElementsByTagName(\"description\").item(0).getTextContent());\n       mapOutcome.setType(element.getElementsByTagName(\"type\").item(0).getTextContent());\n       return mapOutcome;\n   }\n}\n",
        "   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }\n   \n   private MapOutcome xmlToMapOutcome(Element element, boolean easyManner) {\n       MapOutcome mapOutcome = new MapOutcome();\n       mapOutcome.setEasyManner(easyManner);\n       mapOutcome.setId(element.getAttribute(\"id\"));\n       mapOutcome.setName(element.getAttribute(\"name\"));\n       mapOutcome.setType(element.getAttribute(\"type\"));\n       mapOutcome.setValue(element.getAttribute(\"value\"));\n       return mapOutcome;\n   }\n   \n}\n"
    ],
    "validation_result": [
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = archiveCreatorFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapOutcome mapOutcome = xmlToMapOutcome(element, easyManner);\n                   outcome.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(breakDownAlongMistake){\n               throw e;\n           }\n       }\n       return outcome;\n   }",
            "correctness": "uncompilable",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document document = builder.parse(inputStream);\n           XPath xPath = xPathFactory.newXPath();\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);\n           for (int i = 0; i < nodeList.getLength(); i++) {\n               Node node = nodeList.item(i);\n               if (node.getNodeType() == Node.ELEMENT_NODE) {\n                   Element element = (Element) node;\n                   MapResult mapOutcome = xmlToMapOutcome(element, simpleMode);\n                   result.add(mapOutcome);\n               }\n           }\n       } catch (Exception e) {\n           if(failOnError){\n               throw e;\n           }\n       }\n       return result;\n   }"
        }
    ]
}