{
    "output": [
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    result.flip();\n    return result;\n}\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    \n    return result;\n}\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    \n    return result;\n}\n\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n@Override\npublic String decode(final ByteBuffer buffer) {\n    final CharsetDecoder charDecoder = newDecoder();\n    final CharBuffer charBuffer = CharBuffer.allocate(buffer.remaining());\n    \n    while (buffer.remaining() > 0) {\n        final CoderResult outcome = charDecoder.decode(buffer, charBuffer, false);\n        \n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n            if (outcome.isOverflow()) {\n                buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n            }\n        } else {\n            buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n        }\n    }\n    \n    charBuffer.flip();\n    return charBuffer.toString();\n}\n\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n@Override\npublic String decode(final ByteBuffer buffer) {\n    final CharsetDecoder charDecoder = newDecoder();\n    int initial_cbr = buffer.remaining();\n    final CharBuffer charBuffer = CharBuffer.allocate(initial_cbr);\n    \n    while (buffer.remaining() > 0) {\n        final CoderResult outcome = charDecoder.decode(buffer, charBuffer, false);\n        \n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                charBuffer = CompressedFileEncodingAssistant.enlargeBufferWith(charBuffer, approximateAdditionalDecodeingSize(charDecoder, cbr));\n            }\n        } else {\n            buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n        }\n    }\n    \n    charBuffer.flip();\n    return charBuffer.toString();\n}\n\n}\n",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n@Override\npublic String decode(final ByteBuffer buffer) {\n    final CharsetDecoder charDecoder = newDecoder();\n    int initial_cbr = buffer.remaining();\n    final CharBuffer charBuffer = CharBuffer.allocate(initial_cbr);\n    \n    while (buffer.remaining() > 0) {\n        final CoderResult outcome = charDecoder.decode(buffer, charBuffer, false);\n        \n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                charBuffer = CompressedFileEncodingAssistant.enlargeBufferWith(charBuffer, approximateAdditionalDecodeingSize(charDecoder, cbr));\n            }\n        } else {\n            buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n        }\n    }\n    \n    charBuffer.flip();\n    return charBuffer.toString();\n}\n\nprivate int approximateAdditionalEncodeingSize(final CharsetEncoder charEncoder, final int cbr) {\n    return charEncoder.maxBytesPerChar() * cbr;\n}\n\nprivate int approximateAdditionalDecodeingSize(final CharsetDecoder charDecoder, final int cbr) {\n    return charDec",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n@Override\npublic String decode(final ByteBuffer buffer) {\n    final CharsetDecoder charDecoder = newDecoder();\n    int initial_cbr = buffer.remaining();\n    final CharBuffer charBuffer = CharBuffer.allocate(initial_cbr);\n    \n    while (buffer.remaining() > 0) {\n        final CoderResult outcome = charDecoder.decode(buffer, charBuffer, false);\n        \n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                charBuffer = CompressedFileEncodingAssistant.enlargeBufferWith(charBuffer, approximateAdditionalDecodeingSize(charDecoder, cbr));\n            }\n        } else {\n            buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n        }\n    }\n    \n    charBuffer.flip();\n    return charBuffer.toString();\n}\n\nprivate int approximateAdditionalEncodeingSize(final CharsetEncoder charEncoder, final int cbr) {\n    return charEncoder.averageBytesPerChar() * cbr;\n}\n\nprivate int approximateAdditionalDecodeingSize(final CharsetDecoder charDecoder, final int cbr) {\n    return charDec",
        "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}\n\n@Override\npublic String decode(final ByteBuffer buffer) {\n    final CharsetDecoder charDecoder = newDecoder();\n    int initial_cbr = buffer.remaining();\n    final CharBuffer charBuffer = CharBuffer.allocate(initial_cbr);\n    \n    while (buffer.remaining() > 0) {\n        final CoderResult outcome = charDecoder.decode(buffer, charBuffer, false);\n        \n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                charBuffer = CompressedFileEncodingAssistant.enlargeBufferWith(charBuffer, approximateAdditionalDecodeingSize(charDecoder, cbr));\n            }\n        } else {\n            buffer = CompressedFileEncodingAssistant.enlargeBufferWith(buffer, approximateAdditionalDecodeingSize(charDecoder, charBuffer.remaining()));\n        }\n    }\n    \n    charBuffer.flip();\n    final String result = charBuffer.toString();\n    charBuffer.clear();\n    return result;\n}\n\n}\n"
    ],
    "validation_result": [
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    \n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    \n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        },
        {
            "patch": "@Override\npublic ByteBuffer encode(final String tile) {\n    final CharBuffer charBuffer = CharBuffer.wrap(tile);\n    \n    int initial_cbr = charBuffer.remaining();\n    final CharsetEncoder charEncoder = newEncoder();\n    int size = approximateOriginalBufferSize(charEncoder, initial_cbr);\n    ByteBuffer result = ByteBuffer.allocate(size);\n    CharBuffer cb_temp = null;\n    \n    while (charBuffer.remaining() > 0) {\n        final CoderResult outcome = charEncoder.encode(charBuffer, result, false);\n\n        if (!outcome.isUnmappable() &&!outcome.isMalformed()) {\n\n            if (outcome.isOverflow()) {\n                int cbr = charBuffer.remaining();\n                result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cbr));\n            }\n        } else {\n            if (cb_temp == null) {\n                cb_temp = CharBuffer.allocate(initial_cbr);\n            }\n            cb_temp.put(charBuffer);\n            cb_temp.flip();\n            result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n        }\n    }\n    \n    if (cb_temp!= null) {\n        cb_temp.flip();\n        result = CompressedFileEncodingAssistant.enlargeBufferWith(result, approximateAdditionalEncodeingSize(charEncoder, cb_temp.remaining()));\n    }\n    \n    result.flip();\n    return result;\n}",
            "correctness": "compile_success",
            "translated": "@Override\npublic ByteBuffer encode(final String name) {\n    final CharBuffer cb = CharBuffer.wrap(name);\n    \n    int initial_cbr = cb.remaining();\n    final CharsetEncoder enc = newEncoder();\n    int size = estimateInitialBufferSize(enc, initial_cbr);\n    ByteBuffer out = ByteBuffer.allocate(size);\n    CharBuffer tmp = null;\n    \n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n\n        if (!res.isUnmappable() &&!res.isMalformed()) {\n\n            if (res.isOverflow()) {\n                int cbr = cb.remaining();\n                out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, cbr));\n            }\n        } else {\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(initial_cbr);\n            }\n            tmp.put(cb);\n            tmp.flip();\n            out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n        }\n    }\n    \n    if (tmp!= null) {\n        tmp.flip();\n        out = ZipEncodingHelper.growBufferBy(out, estimateIncrementalEncodingSize(enc, tmp.remaining()));\n    }\n    \n    out.flip();\n    return out;\n}"
        }
    ]
}