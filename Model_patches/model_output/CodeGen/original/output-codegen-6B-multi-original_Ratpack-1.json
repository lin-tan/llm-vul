{
    "output": [
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status);\n  response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  Channel channel = ctx.channel();\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    new Headers(),\n    status,\n    HttpVersion.",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultHttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status);\n  response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status);\n  response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  Channel channel = ctx.channel();\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    new Headers(),\n    status,\n    HttpVersion.HTTP_1",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n    HttpVersion.HTTP_1_1,\n    status,\n    Unpooled.EMPTY_BUFFER\n  ",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    new Headers(),\n    status,\n    HttpVersion.HTTP_1_1,\n    null,",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    new Headers(),\n    status,\n    HttpVersion.HTTP_1_1,\n    \"/",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n    HttpVersion.HTTP_1_1,\n    status,\n    Unpooled.copiedBuffer(status.to",
        "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}\n\nprivate void newResponse(ChannelHandlerContext ctx, HttpResponse nettyResponse) throws Exception {\n  if (!nettyResponse.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP response.\", nettyResponse.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers responseHeaders = new NettyHeadersBackedHeaders(nettyResponse.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyResponse, -1L);\n  String transferEncoding = responseHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  ResponseBody responseBody = hasBody? new ResponseBody(contentLength, nettyResponse, ctx) : null;\n  Channel channel = ctx.channel();\n  if (responseBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(responseBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    responseHeaders,\n    nettyResponse.status(),\n    nettyResponse.protocolVersion(),\n    nettyResponse.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    responseBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(RESPONSE_KEY).set(response);\n}\n\nprivate void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {\n  DefaultResponse response = new DefaultResponse(\n    clock.instant(),\n    new Headers(),\n    status,\n    HttpVersion.HTTP_1_1,\n    \"\","
    ],
    "validation_result": [
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        },
        {
            "patch": "private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n  if (!nettyRequest.decoderResult().isSuccess()) {\n    LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n    sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n    return;\n  }\n  Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n  Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n  String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n  boolean hasBody = (contentLength > 0) || (transferEncoding!= null);\n  RequestBody requestBody = hasBody? new RequestBody(contentLength, nettyRequest, ctx) : null;\n  Channel channel = ctx.channel();\n  if (requestBody!= null) {\n    channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n  }\n  InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n  InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n  ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n  DefaultRequest request = new DefaultRequest(\n    clock.instant(),\n    requestHeaders,\n    nettyRequest.method(),\n    nettyRequest.protocolVersion(),\n    nettyRequest.uri(),\n    remoteAddress,\n    socketAddress,\n    serverRegistry.get(ServerConfig.class),\n    requestBody,\n    connectionIdleTimeout,\n    channel.attr(CLIENT_CERT_KEY).get()\n  );\n  channel.attr(REQUEST_KEY).set(request);\n}",
            "correctness": "uncompilable"
        }
    ]
}