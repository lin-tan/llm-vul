{
    "output": [
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n<|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions, false));\n<|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n<|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions, true));\n<|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(dicPermissions);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(encryption.getPermissions()));\n<|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.valueOf(dicPermissions));\n<|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setAccessPermission(new AccessPermission(dicPermissions));\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(AccessPermission.get(dicPermissions));\n<|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                 DecryptionMaterial decryptionMaterial)\n                                 throws IOException\n{\n    if((decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n        String password = material.getPassword();\n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        setDecryptMetadata(encryptMetadata);\n        if(password == null){\n            password = \"\";\n        }\n        int dicLength = 0;\n        if(encryption.getVersion()!= 1 ){\n            dicLength = encryption.getLength() / 8;\n        }else{\n            dicLength = 5;\n        } \n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        byte[] ue = null;\n        byte[] oe = null;\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        byte[] passwordByteArray = password.getBytes(passwordCharset);\n        if(!isOwnerPassword(passwordByteArray, userKey, ownerKey,\n            dicPermissions, documentIDBytes, dicRevision,\n            dicLength, encryptMetadata) )\n            {\n                if(!isUserPassword(passwordByteArray, userKey, ownerKey,\n                    dicPermissions, documentIDBytes, dicRevision,\n                    dicLength, encryptMetadata) )\n                {\n                    throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                } else \n                {\n// buggy lines start:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions));\n// buggy lines end\n                    encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                            dicRevision,dicLength, encryptMetadata, false );\n                }\n            }else{\n                setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                byte[] computedPassword;\n                if ( dicRevision!= 6 && dicRevision!= 5)\n                {\n                    computedPassword = getUserPassword(passwordByteArray,\n                    ownerKey, dicRevision, dicLength );\n                }\n                else\n                {\n                    computedPassword = passwordByteArray;\n                }\n                encryptionKey = computeEncryptedKey(computedPassword, \n                ownerKey, userKey, oe, ue, dicPermissions,\n                documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n            }\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }            \n        if (encryption.getVersion()!= 4 && encryption.getVersion()!= 5)\n        {\n          return;\n        }else{\n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n            if (stdCryptFilterDictionary == null)\n            {\n               return;\n            }\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n            boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n            setAES( aesv2 || aesv3 );\n        }\n    }else{\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n}\n// fixed lines:\n                    setCurrentAccessPermission(new AccessPermission(dicPermissions, encryption));\n<|endofmask|>"
    ],
    "validation_result": [
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n",
            "correctness": "compile_success"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, false));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, true));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(dicPermissions);\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(encryption.getPermissions()));\n",
            "correctness": "compile_success"
        },
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.valueOf(dicPermissions));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setAccessPermission(new AccessPermission(dicPermissions));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(AccessPermission.get(dicPermissions));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "                    setCurrentAccessPermission(new AccessPermission(dicPermissions, encryption));\n",
            "correctness": "uncompilable"
        }
    ]
}