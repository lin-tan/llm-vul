{
    "output": [
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, null);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(inputStream));\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(is);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, url);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, true);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilder.parse(inputStream);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(inputStream.toByteArray()));\n<|endofmask|>",
        "<|endoftext|>private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    config =  config == null? Collections.emptyMap():config;\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        FileUtils.checkReadAllowed(url);\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n        documentBuilderFactory.setNamespaceAware(true);\n        if(StringUtils.isEmpty(path) ){\n            path =  \"/\" ;\n        }\n        XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n        InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ), null);\n// buggy lines start:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n// buggy lines end\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        int i = 0;\n        while ( i < nodeList.getLength()) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            Node node_i = nodeList.item(i);\n            handleNode(stack, node_i, simpleMode);\n            int index = 0;\n            while ( index < stack.size()) {\n                Map<String, Object> stack_first = stack.pollFirst();\n                result.add(new MapResult(stack_first));\n                index++;\n            }\n            i++;\n        }\n    }\n    catch (FileNotFoundException e){\n        if(failOnError){\n            String message = e.getMessage();\n            throw new FileNotFoundException(message);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    catch (Exception e){\n        if(failOnError){\n            throw new Exception(e);\n        }else{\n            Map<String, Object> emptyMap =Collections.emptyMap();\n            MapResult mapResult = new MapResult(emptyMap);\n            return Stream.of(mapResult);\n        }\n    }\n    return result.stream();\n}\n// fixed lines:\n        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(inputStream.getBytes()));\n<|endofmask|>"
    ],
    "validation_result": [
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, null);\n",
            "correctness": "test_timeout"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(inputStream));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(is);\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n",
            "correctness": "test_timeout"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, url);\n",
            "correctness": "test_timeout"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream, true);\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        Document doc = documentBuilder.parse(inputStream);\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(inputStream.toByteArray()));\n",
            "correctness": "uncompilable"
        },
        {
            "patch": "        Document doc = documentBuilderFactory.newDocumentBuilder().parse(new ByteArrayInputStream(inputStream.getBytes()));\n",
            "correctness": "uncompilable"
        }
    ]
}