{
    "output": [
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '\\\\':\n        remove(h, h + 1);\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h < terminal) {\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n<|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        supplant(h, h + 1, \"\\\\/\");\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n        }\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n        }\n        break;\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h + 1 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n<|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>",
        "<|endoftext|>private void cleanString(int begin, int terminal) {\n  boolean shut = false;\n  for (int h = begin; h < terminal; ++h) {\n    char currentChar = JSONlike.charAt(h);\n    switch (currentChar) {\n      case '\\n': supplant(h, h + 1, \"\\\\n\"); break;\n      case '\\r': supplant(h, h + 1, \"\\\\r\"); break;\n      case '\\u2028': supplant(h, h + 1, \"\\\\u2028\"); break;\n      case '\\u2029': supplant(h, h + 1, \"\\\\u2029\"); break;\n      case '\"': case '\\'':\n        if (h == begin) {\n          if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n        } else {\n          if (h + 1 == terminal) {\n            char beginDelimiter = JSONlike.charAt(begin);\n            if (beginDelimiter!= '\\'') {\n              beginDelimiter = '\"';\n            }\n            shut = beginDelimiter == currentChar;\n          }\n          if (shut) {\n            if (currentChar == '\\'') { supplant(h, h + 1, '\"'); }\n          } else if (currentChar == '\"') {\n            embed(h, '\\\\');\n          }\n        }\n        break;\n// buggy lines start:\n      case '/':\n        if (h > begin && h + 2 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n// buggy lines end\n      case ']':\n        if (h + 2 < terminal && ']' == JSONlike.charAt(h + 1)\n            && '>' == JSONlike.charAt(h + 2)) {\n          supplant(h, h + 1, \"\\\\u005d\");\n        }\n        break;\n      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n          case '/': case '\"':\n            ++h;\n            break;\n          case 'v':\n            supplant(h, h + 2, \"\\\\u0008\");\n            ++h;\n            break;\n          case 'x':\n            if (h + 4 < terminal && whetherHexadecimalAt(h+2) && whetherHexadecimalAt(h+3)) {\n              supplant(h, h + 2, \"\\\\u00\");\n              h += 3;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case 'u':\n            if (h + 6 < terminal && whetherHexadecimalAt(h + 2) && whetherHexadecimalAt(h + 3)\n                && whetherHexadecimalAt(h + 4) && whetherHexadecimalAt(h + 5)) {\n              h += 5;\n              break;\n            }\n            remove(h, h + 1);\n            break;\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n            int octalTerminal = h + 1;\n            if (octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n              ++octalTerminal;\n              if (currentChar <= '3' && octalTerminal + 1 < terminal && whetherOctalAt(octalTerminal + 1)) {\n                ++octalTerminal;\n              }\n              int content = 0;\n              for (int k = h; k < octalTerminal; ++k) {\n                content = (content << 3) | (JSONlike.charAt(k) - '0');\n              }\n              supplant(h + 1, octalTerminal, \"u00\");\n              addOnHexadecimal(content, 2);\n            }\n            h = octalTerminal - 1;\n            break;\n          default:\n            remove(h, h + 1);\n            break;\n        }\n        break;\n      default:\n        if (currentChar < 0x20) {\n          if (currentChar == 9 || currentChar == 0xa || currentChar == 0xd) { continue; }\n        } else if (currentChar < 0xd800) {\n          continue;\n        } else if (currentChar < 0xe000) {\n          if (Character.whetherHighAlternate(currentChar) && h+1 < terminal\n              && Character.whetherLowAlternate(JSONlike.charAt(h+1))) {\n            ++h;\n            continue;\n          }\n        } else if (currentChar <= 0xfffd) {\n          continue;\n        }\n        supplant(h, h + 1, \"\\\\u\");\n        for (int k = 4; --k >= 0;) {\n          cleanedJSON.append(HEX_NUMBER[(currentChar >>> (k << 2)) & 0xf]);\n        }\n        break;\n    }\n  }\n  if (!shut) { embed(terminal, '\"'); }\n}\n// fixed lines:\n      case '/':\n        if (h > begin && h + 1 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n<|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>"
    ],
    "validation_result": [
        {
            "patch": "      case '\\\\':\n        remove(h, h + 1);\n",
            "correctness": "uncompilable",
            "translated": "      case '\\\\':\n        elide(i, i + 1);\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h < terminal) {\n",
            "correctness": "uncompilable",
            "translated": "      case '/':\n        if (i > start && i < end) {\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        if (i > start && i < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n          insert(i, '\\\\');\n        }\n"
        },
        {
            "patch": "      case '/':\n        supplant(h, h + 1, \"\\\\/\");\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        replace(i, i + 1, \"\\\\/\");\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n",
            "correctness": "uncompilable",
            "translated": "      case '/':\n        if (i > start && i < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n        }\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        if (i > start && i < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n        }\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n        }\n        break;\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        if (i > start && i < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n        }\n        break;\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h + 1 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)\n            && 'c' == (JSONlike.charAt(h + 2) | 32)) {\n          embed(h, '\\\\');\n        }\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        if (i > start && i + 1 < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)\n            && 'c' == (jsonish.charAt(i + 2) | 32)) {\n          insert(i, '\\\\');\n        }\n"
        },
        {
            "patch": "      case '\\\\':\n        if (h + 1 == terminal) {\n          remove(h, h + 1);\n          break;\n        }\n        char nextChar = JSONlike.charAt(h + 1);\n        switch (nextChar) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n",
            "correctness": "uncompilable",
            "translated": "      case '\\\\':\n        if (i + 1 == end) {\n          elide(i, i + 1);\n          break;\n        }\n        char sch = jsonish.charAt(i + 1);\n        switch (sch) {\n          case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n"
        },
        {
            "patch": "      case '/':\n        if (h > begin && h + 1 < terminal && '<' == JSONlike.charAt(h - 1)\n            &&'s' == (JSONlike.charAt(h + 1) | 32)) {\n          embed(h, '\\\\');\n        }\n        break;\n",
            "correctness": "compile_success",
            "translated": "      case '/':\n        if (i > start && i + 1 < end && '<' == jsonish.charAt(i - 1)\n            &&'s' == (jsonish.charAt(i + 1) | 32)) {\n          insert(i, '\\\\');\n        }\n        break;\n"
        }
    ]
}