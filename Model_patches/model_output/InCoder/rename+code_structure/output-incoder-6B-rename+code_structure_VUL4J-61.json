{
    "output": [
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   \n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   \n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.new",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   \n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPath",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n\n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.new",
        "<|endoftext|>   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n<|mask:0|>Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }\n   \n   private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n           \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream"
    ],
    "validation_result": [
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = archiveCreatorFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder archiveCreatorBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = archiveCreatorBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        },
        {
            "patch": "private Stream<MapOutcome> xmlXpathToMapOutcome(@Name(\"url\") String URL, boolean easyManner, String way, Map<String, Object> setting) throws Exception {\n       setting =  setting == null? Collections.emptyMap():setting;\n       boolean breakDownAlongMistake = (boolean) setting.getOrDefault(\"failOnError\", true);\n       List<MapOutcome> outcome = new ArrayList<>();\n       try {\n           FileUtils.examineReadPermitted(URL);\n           DocumentBuilderFactory archiveCreatorFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           archiveCreatorFactory.setIgnoringElementContentWhitespace(true);\n           archiveCreatorFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(way) ){\n               way =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(way);\n           InputStream inputStream = Util.unlockInDataSequence(URL, (Map) setting.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = archiveCreatorFactory.newDocumentBuilder().parse(inputStream);\n           NodeList vertexListing = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int m = 0;\n           while ( m < vertexListing.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_m = vertexListing.item(m);\n               manageNode(stack, node_m, easyManner);\n               int position = 0;\n               while ( position < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   outcome.add(new MapOutcome(stack_first));\n                   position++;\n               }\n               m++;\n           }\n       }\n       catch (FileNotFoundException x){\n           if(breakDownAlongMistake){\n               String message = x.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception x){\n           if(breakDownAlongMistake){\n               throw new Exception(x);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapOutcome mapResult = new MapOutcome(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return outcome.stream();\n   }",
            "correctness": "test_timeout",
            "translated": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }"
        }
    ]
}