{
    "output": [
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document ",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n\n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document ",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = builder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = ",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config, boolean failOnError) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* ",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           Document doc = documentBuilderFactory.",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config, boolean failOnError) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", failOnError);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = builder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n   \n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           Document doc = documentBuilderFactory.newDocumentBuilder",
        "<|endoftext|>   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           <|mask:0|>\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n<|mask:0|>DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }\n\n   private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           Document doc = documentBuilderFactory.newDocument"
    ],
    "validation_result": [
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = builder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = builder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        },
        {
            "patch": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n       config =  config == null? Collections.emptyMap():config;\n       boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n       List<MapResult> result = new ArrayList<>();\n       try {\n           FileUtils.checkReadAllowed(url);\n           DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n           XPathFactory xPathFactory = XPathFactory.newInstance();\n           documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n           documentBuilderFactory.setNamespaceAware(true);\n           if(StringUtils.isEmpty(path) ){\n               path =  \"/\" ;\n           }\n          \n           XPathExpression xPathExpression = xPathFactory.newXPath().compile(path);\n           InputStream inputStream = Util.openInputStream(url, (Map) config.getOrDefault( \"headers\", Collections.emptyMap() ) , null);\n           /* BUG: \n            * Document doc = documentBuilderFactory.newDocumentBuilder().parse(inputStream);\n            * FIXED: \n            */\n           DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n           Document doc = documentBuilder.parse(inputStream);\n           NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n           int i = 0;\n           while ( i < nodeList.getLength()) {\n               final Deque<Map<String, Object>> stack = new LinkedList<>();\n               Node node_i = nodeList.item(i);\n               handleNode(stack, node_i, simpleMode);\n               int index = 0;\n               while ( index < stack.size()) {\n                   Map<String, Object> stack_first = stack.pollFirst();\n                   result.add(new MapResult(stack_first));\n                   index++;\n               }\n               i++;\n           }\n       }\n       catch (FileNotFoundException e){\n           if(failOnError){\n               String message = e.getMessage();\n               throw new FileNotFoundException(message);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n       }\n       catch (Exception e){\n           if(failOnError){\n               throw new Exception(e);\n           }else{\n               Map<String, Object> emptyMap =Collections.emptyMap();\n               MapResult mapResult = new MapResult(emptyMap);\n               return Stream.of(mapResult);\n           }\n               \n       }\n       return result.stream();\n   }",
            "correctness": "test_timeout"
        }
    ]
}