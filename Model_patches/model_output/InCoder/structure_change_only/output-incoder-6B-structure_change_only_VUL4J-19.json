{
    "output": [
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n           ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n           ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray, ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword = passwordByte",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray, ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword = passwordByte",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n               ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n               ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n                   ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray,\n                   ownerKey, dicRevision, dicLength );\n       }\n       else\n       {\n           computedPassword",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray, ownerKey, dicRevision, dicLength);\n       }\n       else\n       {\n           computedPassword = passwordByteArray;",
        "<|endoftext|>   public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       <|mask:0|>\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n       \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n<|mask:0|>setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }\n   \n   private boolean isOwnerPassword(byte[] passwordByteArray, byte[] userKey, byte[] ownerKey,\n                                   int dicPermissions, byte[] documentIDBytes, int dicRevision,\n                                   int dicLength, boolean encryptMetadata)\n                                   throws InvalidPasswordException\n   {\n       byte[] computedPassword;\n       if ( dicRevision != 6 && dicRevision != 5)\n       {\n           computedPassword = getUserPassword(passwordByteArray, ownerKey, dicRevision, dicLength);\n       }\n       else\n       {\n           computedPassword = passwordByteArray;"
    ],
    "validation_result": [
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "compile_success"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "uncompilable"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "uncompilable"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "compile_success"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "compile_success"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "uncompilable"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "compile_success"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "uncompilable"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getUserAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "uncompilable"
        },
        {
            "patch": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                    DecryptionMaterial decryptionMaterial)\n                                    throws IOException\n   {\n       if((decryptionMaterial instanceof StandardDecryptionMaterial))\n       {\n           \n           byte[] userKey = encryption.getUserKey();\n           byte[] ownerKey = encryption.getOwnerKey();\n           StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n           String password = material.getPassword();\n       \n           boolean encryptMetadata = encryption.isEncryptMetaData();\n           setDecryptMetadata(encryptMetadata);\n           \n           if(password == null){\n               password = \"\";\n           }\n           int dicLength = 0;\n           if(encryption.getVersion() != 1 ){\n               dicLength = encryption.getLength() / 8;\n           }else{\n               dicLength = 5;\n           } \n           byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);    \n           int dicPermissions = encryption.getPermissions();\n           int dicRevision = encryption.getRevision();\n           byte[] ue = null;\n           byte[] oe = null;\n           Charset passwordCharset = Charsets.ISO_8859_1;\n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               passwordCharset = Charsets.UTF_8;\n               ue = encryption.getUserEncryptionKey();\n               oe = encryption.getOwnerEncryptionKey();\n           }\n           \n           byte[] passwordByteArray = password.getBytes(passwordCharset);\n           if( !isOwnerPassword(passwordByteArray, userKey, ownerKey,\n               dicPermissions, documentIDBytes, dicRevision,\n               dicLength, encryptMetadata) )\n               {\n                   if( !isUserPassword(passwordByteArray, userKey, ownerKey,\n                       dicPermissions, documentIDBytes, dicRevision,\n                       dicLength, encryptMetadata) )\n                   {\n                       throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n                   } else \n                   {\n                       /* BUG: \n                        * setCurrentAccessPermission(new AccessPermission(dicPermissions));\n                        * FIXED: \n                        */\n                       setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                       encryptionKey = computeEncryptedKey( passwordByteArray, ownerKey, userKey, oe, ue, dicPermissions,documentIDBytes,\n                               dicRevision,dicLength, encryptMetadata, false );\n                   }\n               }else{\n                   setCurrentAccessPermission(AccessPermission.getOwnerAccessPermission());\n                   byte[] computedPassword;\n                   if ( dicRevision != 6 && dicRevision != 5)\n                   {\n                       computedPassword = getUserPassword(passwordByteArray,\n                       ownerKey, dicRevision, dicLength );\n                   }\n                   else\n                   {\n                       computedPassword = passwordByteArray;\n               \n                   }\n                   encryptionKey = computeEncryptedKey(computedPassword, \n                   ownerKey, userKey, oe, ue, dicPermissions,\n                   documentIDBytes, dicRevision,dicLength, encryptMetadata, true );\n               }\n           \n           if (dicRevision == 6 || dicRevision == 5)\n           {\n               validatePerms(encryption, dicPermissions, encryptMetadata);\n           }            \n           if (encryption.getVersion() != 4 && encryption.getVersion() != 5)\n           {\n             return;\n           }else{\n               PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n               if (stdCryptFilterDictionary == null)\n               {\n                  return;\n               }\n               COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n               boolean aesv2 = COSName.AESV2.equals(cryptFilterMethod);\n               boolean aesv3 = COSName.AESV3.equals(cryptFilterMethod);\n               setAES( aesv2 || aesv3 );\n           }\n       }else{\n           throw new IOException(\"Decryption material is not compatible with the document\");\n       }\n   }",
            "correctness": "compile_success"
        }
    ]
}