{
    "function range": "96,2-110,2",
    "output": [
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d.doubleValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UN",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, short c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float c )\n{\n\tString cStr = String.valueOf(c);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, long i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, float i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, double i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d.doubleValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UN",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(",
        "<|endoftext|>public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n <|mask:0|>\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\n<|mask:0|>\tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, int i )\n{\n\tString cStr = String.valueOf(i);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, long l )\n{\n\tString cStr = String.valueOf(l);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, float f )\n{\n\tString cStr = String.valueOf(f);\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}\npublic String encodeCharacter( char[] immune, double d )\n{\n\tString cStr = String.valueOf(d.doubleValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_"
    ],
    "validation_result": [
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t\treturn cStr;\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        },
        {
            "patch": "public String encodeCharacter( char[] immune, Character c )\n{\n\tString cStr = String.valueOf(c.charValue());\n\tbyte[] bytes;\n\tStringBuilder sb;\n/* BUG : \n*\tif(UNENCODED_SET.contains(c))\n* FIXED: \n*/\n \tif(UNENCODED_SET.contains(cStr))\n\t{\n\t\treturn cStr;\n\t}\n\tbytes = toUtf8Bytes(cStr);\n\tsb = new StringBuilder(bytes.length * 3);\n\tfor(byte b : bytes)\n\t\tappendTwoUpperHex(sb.append('%'), b);\n\treturn sb.toString();\n}",
            "correctness": "compile_success"
        }
    ]
}